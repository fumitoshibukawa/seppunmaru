/***********************************************************************/
/*                                                                     */
/*  FILE        :interrput_serial.c                                    */
/*  DATE        : ●2025.4.7                                          */
/*  DESCRIPTION :] Program                                             */
/*  CPU TYPE    :RX62N                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/

// 注意点：初期化のため，電源を入れてから5秒間はボタンを押さないこと
// b: 青ボール，r: 赤ボール，p: ペットボトル，m: マックス缶，z: 贅沢微糖

// #include "typedefine.h"
#ifdef __cplusplus
// #include <ios>                   // Remove the comment when you use ios
// _SINT ios_base::Init::init_cnt;  // Remove the comment when you use ios
#endif

#include "common.h"
#include "serial.hpp"
#include "iodefine.h"
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdbool.h>  // true, false用

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

// マクロ定義
#define  BUFFER_SIZE 			  41
#define  ENABLE_CONSOLE_FEED_BACK  1 // user:1 RaspberryPi:0

#define  FIRST_END_POS   10
#define  SECOND_END_POS  41  // 36→41
#define  THIRD_END_POS   70  // 72
#define  END_POS 	   110
#define  SECTION_HEIGHT 32.5f   //8個あるエリアの1つ分の辺の長さ30.0f(cm) //正確には，1〜3：325mm, 4：225mm

#define  RIGHT_SEARCH_START_POS		 52.0f  //51.7 [cm]→56
#define  LEFT_SEARCH_START_POS 		 94.5f  //93→95→96
#define  ADJUSTMENT_SEARCH_START_POS  7.9f
#define  DISTANCE_FROM_STEER_CENTER  21.0f //19.0f

// グローバル変数定義
// シリアル通信用
char  input_buffer[BUFFER_SIZE];

// ライントレース用
static int  Feed_flag;       // フィードバック関数内での制御フラグ
static int  All_black_flag;  // ライントレース用のフラッグ
static int  search_end_flag;
static int  L_power, R_power;

// ロボットが何[cm]動いたかの認識用
float  moving_robot_distance = 0.0f;

// 探索でロボットが何[cm]動いたかの認識用
float  right_search_moving_distance = 0.0f;
float   left_search_moving_distance = 0.0f;

// PSDセンサ
#define  Fc_2 2.0f  // 遮断周波数[Hz]
float  Xf[12];  // フィルタリング前
float  Yf[12];  // フィルタリング後
float  Fs_2;    // 計測周波数
float  Fac_2;
float  F_B_2, F_C_2;
float  Distance1;  // PSDセンサで測定した距離
float  Distance2;
float  Distance3;

// 軌道追従用
ki_sharedType  Ki;
ct_sharedType  Ct;

// タイムカウント用
volatile long int  sleep_count = 0 ;
volatile long int  time_count  = 0;

// 回収処理
void Slave();
void Collect();

// サーチの回数
int step = 0;

// シリアル通信の受信用
int16_t charget();

// タイマ割り込みの設定
void InitCMT1();

// 割り込み処理の内容
void int_cmt1();

// 軌道追従
static void traj_tracking( float x_f, float tht_f, float t_f );
static void traj_plan_3(int jnt, float x_i, float x_f, float t_i, float t_f);
static void make_traj( float t_i, float t_f );

// 並進と回転
static void translate(float distance);
static void rotate(float angle);

// それぞれの初期化処理
void ad_setup( void );
void initMotor( void );
void initMTU_enco( void );
void initClock( void );
void initIO( void );

// パラメータの初期化
static void init_para( void );

// マイコンの初期化
static void init_micon( void );

// ロボットの初期化
static void init_robot( void );

// 時間用
static void start_time( ct_timeType *p );
static void reset_time( ct_timeType *p );
static int inc_time(    ct_timeType *p );

// モータ関数
void motor( int duty, int motNum );

// エンコーダの値読み取り
static int enco( int no );

// ライントレース用
void Line_Trace_PD( int sensor_2, int sensor_3 );
void Line_Trace_PD_slow( int sensor_2, int sensor_3 );
void Line_Trace( int lap );
void Line_Trace_Slow( int lap );

// ペットボトルまで直接向かうライントレース
void Go2Pet( void );

void Search_Can( void );
void OnlyPet( void );
int Distinguish_item( void );
int Search( float deg );

// PSDセンサ
void  PSD_sensor( void );

// スリープ関数
void sleep( int sleep_time );

// ペットボトルを処理するための関数
void GO_CATCH_PUT_PET(  void );

// セットポジションに行くための処理
void go2setposi( void );

// リターンボーナス用のプログラム
void return_bonus( char color );

volatile float  free_memory[10] = {0};  // 多重割り込みデバッグ用

// 自由ボールを落とす
void free_ball2( void );

// 自由ボールを落とす処理をした後に探索開始位置に行く
void go2search_start_posi( void );

// 車輪の中心からの距離と角度を計算
float calculate_distance_from_steer_center( float dis, float deg );
float calculate_angle_from_steer_center( float dis, float deg );

// PSDセンサの値をみて軌道追従を止まらされるかどうかのモード切替用
static int  STOP_PSD_ENABLE;  // true:PSDセンサーの値を見て止まる　false:通常の軌道追従

// 右探索か左探索か切り替わったかの認識用
static  int16_t CHANGE_SPACE_FLAG;

// 右探索か左探索かの見極め用
static  int16_t search_space_flag;

// 探索終了フラグ
static int  FINISH_FLAG;

// 左の何番目を探索中か判断するフラグ
static int  left_one_flag;
static int  left_three_flag;
static int  left_four_flag;
volatile  int16_t left_two_flag;

// 右の何番目を探索中か判断するフラグ
static int  right_one_flag;
static int  right_three_flag;
static int  right_four_flag;
volatile static  int16_t right_two_flag;

// 物体の目の前にあることを認識するフラグ
static int  GO_AHEAD_FLAG;

// 発見したことを判断するフラグ
int16_t find_flag = false;

// ２個回収時にゴールへ向かうか否か判断するフラグ
int goal_flag;

//オブジェクトの種類
enum Type {
	RedBall,
	BlueBall,
	Zeitaku,
	Pyramid,
	MaxCoffee,
	Goal,// 2個同じ場合
	None
};

// Raspiから取得したオブジェクトタイプ，距離，角度を記録するためのストラクチャ．
typedef struct {
	enum Type type;      // r:赤ボ　b:青ボ z:贅沢微糖 p:ピラミッド m:マックス缶 空:何もなし
	float distance;
	float angle;
} Object;

Object obj1;
Object obj2;

void object_catch( char shape );
void catch_ball(float distance, float angle);
void catch_zeitaku(float distance, float angle);
void catch_pyramid(float distance, float angle);
void catch_maxcoffee(float distance, float angle);

// 物体を排出し，セットポジションまで戻る．
void Emit_Items2( char color, int count );
void emit_redball(Object obj2);
void emit_blueball(Object obj2);
void emit_zeitaku(Object obj2);
void emit_maxcoffee(void);
void emit_pyramid(void);

void emit_redball_last(Object obj2);
void emit_blueball_last(Object obj2);
void emit_zeitaku_last(Object obj2);


void recovery_linetrace( char object, float angle, int position );
/*
void back_set_posi_HUG( float dis, float deg, float time, char color, int16_t search_space_flag,
						int r_count, int l_count );
void back_set_posi_UVG( float dis, float deg, float time, char color, int16_t search_space_flag,
						int r_count, int l_count );
*/
void return_to_line(void);

// ペットボトルをとる処理をした後に，ペットボトルをおく処理
void PUT_PET( void );

// RXとRaspberryPiの通信プログラム
//void RXPi( void );


//画像認識を実行し，結果を受け取る関数
Object search_oneball_or_zeitaku(void);
Object search_zeitaku(void);
Object search_maxcoffee_or_pyramid(void);

// 各種フラグ関係の初期化
void init_flag( void );

// 最初の挙動
void transform_robot( void );


// --------------------------------
// --- 割り込み (feedback) 関数 ---
// --------------------------------
void InitCMT1( void )
{
	MSTP(CMT1) = 0;	          // CMTモジュールのスタンバイ解除
	CMT.CMSTR0.BIT.STR1 = 0;  // カウンタストップ
	CMT1.CMCR.BIT.CMIE  = 1;  // 割込許可
	CMT1.CMCNT = 0;           // カウンタクリア

	// コンペアマッチするまでの期間を設定
	// Count_sec  = 24000000/8/CMT1.CMCOR;  // MTUのクロックは 24 MHz
	CMT1.CMCR.BIT.CKS = 3;  // クロック選択  00：Pφ/8  01：Pφ/32  10：Pφ/128  11：Pφ/512

	float N = ( ( 48000000 / 512 ) * RsampTime ) - 1;

	CMT1.CMCOR = (uint16_t)N;  // 469: (512/24,000,000)*469= 10 msec  -> 100[Hz]

	IEN(CMT1, CMI1) = 1;
	IPR(CMT1, CMI1) = 1;  // 割り込み優先レベル	低0⇔15高
	IR( CMT1, CMI1) = 0;  // 割り込みステータスフラグ　割り込み要求なし

	CMT.CMSTR0.BIT.STR1 = 1;  // カウンタスタート
}

// ************************
// *** 割り込み処理関数 ***
// *** feedback 関数    ***
// ************************
void int_cmt1( void )
{
	int i, jnt;
	char str[30];

	sleep_count += 1;//スリープ用カウント
	time_count  += 10;//時計　[ms]
	PSD_sensor();

	// --------------------------------------
	// --- エンコーダを用いた閉ループ制御 ---
	// --------------------------------------
	if( Feed_flag == ENCO ){

		for( jnt= MOTOR_L; jnt<= MOTOR_R; jnt++ ){

			// --- 車輪の回転角を計測 ---
			Ct.jnt[jnt].last.d    = Ct.jnt[jnt].present.d;
			Ct.jnt[jnt].present.d = (float)Ct.enco_dir[jnt]*enco(jnt)*(Ct.WPulse2Rad)/(Ct.Tr);
			Ct.jnt[jnt].present.v = (Ct.jnt[jnt].present.d - Ct.jnt[jnt].last.d)/RsampTime;

			// --- 車輪の制御 ---
			Ct.jnt[jnt].delta = (Ct.start_present_d[jnt] + Ki.traj[jnt][Ct.dTime.val].d)
								 - (Ct.jnt[jnt].present.d);

			// --- 出力電圧を計算 ---
			Ct.pwm[jnt] = (int)(  (Ct.jnt[jnt].gain.kp)*(Ct.jnt[jnt].delta)
			                    - (Ct.jnt[jnt].gain.kv)*(Ct.jnt[jnt].present.v) );

			motor( (Ct.mot_dir[jnt])*Ct.pwm[jnt], jnt );
		}

		// --- 時間を進める ---
		Ct.timeFlag = inc_time(&Ct.dTime);
	}

	// ----------------------------------------------
	// --- フォトインタラプタを用いた開ループ制御 ---
	// ----------------------------------------------
	if( Feed_flag == PHOTO ){

		STOP_ENCO_COUNT;
		Line_Trace_PD( Photo_2, Photo_3 );
	}

	if( Feed_flag == PHOTO_SLOW ){

		STOP_ENCO_COUNT;
		Line_Trace_PD_slow( Photo_2, Photo_3 );
	}

	// ----------------
	// --- 静止状態 ---
	// ----------------
	else if( Feed_flag == STOP2 ){

		// モータ停止
		for( jnt=MOTOR_L; jnt<=MOTOR_R; jnt++ ){
			motor( 0, jnt );
		}

		// エンコーダのカウント停止
		STOP_ENCO_COUNT;
	}
}

// --------------------------------------
// --- エンコーダを用いた軌道追従制御 ---
// --------------------------------------
static void
traj_tracking( float x_f, float tht_f, float t_f )
{
	int  jnt;
	float  x_i, tht_i, t_i;

	x_i   = 0.0f;
	tht_i = 0.0f;
	t_i   = 0.0f;

	traj_plan_3( DDis,   x_i,   x_f*0.01f,   t_i, t_f );
	traj_plan_3( DTht, tht_i, tht_f*Deg2Rad, t_i, t_f );

	make_traj( t_i, t_f );

	Ct.dTime.stopVal = (int)( (t_f-t_i)*1000/SampTime );
	start_time( &Ct.dTime );

	Ct.timeFlag = !Reached;
	Feed_flag = ENCO;
	START_ENCO_COUNT;  // エンコーダのカウント開始

	while( Ct.timeFlag != Reached ){

		if(STOP_PSD_ENABLE){

			if( Distance1 < 190 || Distance2 < 190 || Distance3 < 100 ){

				// 物体の目の前で止まったことになる．
				GO_AHEAD_FLAG = true;

				break;
			}
		}
	}

	Feed_flag = STOP2;

	reset_time( &Ct.dTime );

	// 現在位置を取得
	for( jnt= MOTOR_L; jnt<= MOTOR_R; jnt++ ){
		Ct.start_present_d[jnt] = Ct.jnt[jnt].present.d;
	}

}

// --------------------------------
// --- 目標の本体速度軌道を生成 ---
// --------------------------------
static void
traj_plan_3( int jnt, float x_i, float x_f, float t_i, float t_f )
{
	int  i;
	int  imti, imtf;
	float  j;
	float  a0, a2, a3;
	float  pos_present=0.0f, pos_last=0.0f;

	a0 =  x_i;
	a2 =  3.0f*(x_f-x_i)/((t_f-t_i)*(t_f-t_i));
	a3 = -2.0f*(x_f-x_i)/((t_f-t_i)*(t_f-t_i)*(t_f-t_i));

	imti = (int)(t_i/ RsampTime);
	imtf = (int)(t_f/ RsampTime);

	for( i=imti; i<=imtf; i++ ){

		pos_last= pos_present;

		j = ((float)i-(float)imti)*RsampTime;

		pos_present = a0 + a2*j*j + a3*j*j*j;

		if( i==imti || i==imtf ){
			Ki.in[jnt][i] = 0.0f;
		}
		else{
			Ki.in[jnt][i] = (pos_present - pos_last)/RsampTime;
		}
	}
}

// ----------------------------
// --- 目標の車輪軌道を生成 ---
// ----------------------------
static void
make_traj( float t_i, float t_f )
{
	int  i, jnt;
	int  imti, imtf;

	imti = (int)(t_i/ RsampTime);
	imtf = (int)(t_f/ RsampTime);

	for( i=imti; i<=imtf; i++ ){

		for( jnt= MOTOR_L; jnt<= MOTOR_R; jnt++ ){

			// --- 各車輪の目標角速度を求める ---
			if( jnt == MOTOR_L ){
				Ki.traj[jnt][i].v =
				( Ki.in[DDis][i] - (Ki.W)*(Ki.in[DTht][i])/2.0f )/(Ki.r);
			}
			else if( jnt == MOTOR_R ){
				Ki.traj[jnt][i].v =
				( Ki.in[DDis][i] + (Ki.W)*(Ki.in[DTht][i])/2.0f )/(Ki.r);
			}
			if( i>=1 ){
				Ki.traj[jnt][i].d = (Ki.traj[jnt][i-1].d) + (Ki.traj[jnt][i].v)*RsampTime;
			}
			else{
				Ki.traj[jnt][i].d = 0;
			}
		}
	}
}

// ----------------------------------
// --- traj_trackingによる並進移動 ---
// ----------------------------------
static void
translate(float distance)
{
	//最適な移動時間を計算する
	float time;
	float acc_root = 0.29f;            // 0.7→0.36→0.3 // 加速度の平方根　摩擦力と車重の兼ね合いで調整する
	time = acc_root * sqrt(fabsf(distance));  // 等加速度運動で発進，停止するときの時間を計算

	//並進移動
	traj_tracking(distance, 0.0f, time);

	//debug
	rprint("Traslate  dist:");
	rprint(distance);
	rprint("cm  sec:");
	rprint(time);
	rprintln("sec");
}

// ----------------------------------
// --- traj_trackingによる回転移動 ---
// ----------------------------------
static void
rotate(float angle)
{
	//最適な回転時間を計算する
	float time;
	float ang_acc_root = 0.24f;                // 0.3 // 角加速度の平方根　摩擦力と慣性モーメントの兼ね合いで調整する
	time = ang_acc_root * sqrt(fabsf(angle));  // 等加速度運動で回転，停止するときの時間を計算

	//回転移動
	traj_tracking(0.0f, angle, time);

	//debug
	rprint("Rotate  angle:");
	rprint(angle);
	rprint("°  sec:");
	rprint(time);
	rprintln("sec");
}

// ----------------
// --- ad_setup ---
// ----------------
void ad_setup( void )
{
	// 10ビットADコンバータの選択
	SYSTEM.MSTPCRA.BIT.MSTPA22 = 0;
	SYSTEM.MSTPCRA.BIT.MSTPA23 = 0;

	// ポート設定
	PORT4.DDR.BIT.B4 = 0; PORT4.ICR.BIT.B4 = 1;  // 傾斜センサ ?
	PORT4.DDR.BIT.B5 = 0; PORT4.ICR.BIT.B5 = 1;  // 傾斜センサ ?
	PORT4.DDR.BIT.B1 = 0; PORT4.ICR.BIT.B1 = 1;
	PORT4.DDR.BIT.B2 = 0; PORT4.ICR.BIT.B2 = 1;
	PORT4.DDR.BIT.B0 = 0; PORT4.ICR.BIT.B0 = 1;  // 後ろのPSDセンサ

	// AD0モジュールスタンバイ
	AD0.ADCSR.BIT.ADST  = 0;  // AD変換停止
	AD0.ADCR.BIT.MODE   = 2;  // 連続スキャンモード（0だとシングルモード）
	AD0.ADCSR.BIT.CH    = 3;  // チャンネル選択
	AD0.ADCR.BIT.CKS    = 3;  // クロック選択
	AD0.ADDPR.BIT.DPSEL = 0;  // LSB詰め

	AD0.ADCSR.BIT.ADIE = 1;
	AD0.ADCSR.BIT.ADST = 1;   // AD変換開始

	// AD1モジュールスタンバイ
	AD1.ADCSR.BIT.ADST  = 0;  // AD変換停止
	AD1.ADCR.BIT.MODE   = 2;  // 連続スキャンモード（0だとシングルモード）
	AD1.ADCSR.BIT.CH    = 3;  // チャンネル選択
	AD1.ADCR.BIT.CKS    = 3;  // クロック選択
	AD1.ADDPR.BIT.DPSEL = 0;  // LSB詰め

	AD1.ADCSR.BIT.ADIE = 1;
	AD1.ADCSR.BIT.ADST = 1;   // AD変換開始
}

// -----------------
// --- InitMOTOR ---
// -----------------
void
initMotor( void )
{
	// 初期化
	MSTP(MTU6) = 0;
	MSTP(MTU9) = 0;

	MTUB.TSTR.BIT.CST0 = 0;  // 6 カウント停止
	MTUB.TSTR.BIT.CST3 = 0;  // 9 カウント停止

	// カウントクロックφ64
	MTU6.TCR.BIT.TPSC = 0;	// PCLK 48MHz
	MTU9.TCR.BIT.TPSC = 0;

	// カウンタクリア(TGRC(A)利用)
	MTU6.TCR.BIT.CCLR = 1;
	MTU9.TCR.BIT.CCLR = 1;

	// PWMモードに設定
	MTU6.TMDR.BIT.MD = 2; // PWM1
	MTU9.TMDR.BIT.MD = 2; // PWM1

	// 波形選択　TGRC(A)..Low→High(周期)
	MTU6.TIORH.BIT.IOA = 2;
	MTU9.TIORH.BIT.IOA = 2;

	// 波形選択　TGRD(B)..Low→Low(Duty)
	MTU6.TIORH.BIT.IOB = 1;
	MTU9.TIORH.BIT.IOB = 1;

	// カウント値設定
	MTU9.TGRA = 1023;  //カウントクリア要因
	MTU9.TGRB = 0;
	MTU6.TGRA = 1023;  //カウントクリア要因
	MTU6.TGRB = 0;
	// カウントスタート
	MTUB.TSTR.BIT.CST0 = 1;  //6 カウントスタート
	MTUB.TSTR.BIT.CST3 = 1;  //9 カウントスタート

	// モータ回転方向制御端子の出力設定
	PORT5.DDR.BIT.B0 = 1;
	PORT5.DDR.BIT.B1 = 1;
}

// ----------------------------
// --- エンコーダ初期化関数 ---
// ----------------------------
void
initMTU_enco( void )
{
	// 入力バッファに転送するように。
	// デジタル入力として利用する場合に設定。
	PORT2.ICR.BIT.B2 = 1;
	PORT2.ICR.BIT.B3 = 1;
	PORT2.ICR.BIT.B4 = 1;
	PORT2.ICR.BIT.B5 = 1;

	MSTP(MTUA) = 0;
	MSTP(MTUB) = 0;
	MSTP(MTU1) = 0;
	MSTP(MTU2) = 0;

	MTUA.TSTR.BIT.CST1 = 0;  // MTU21カウントストップ
	MTUA.TSTR.BIT.CST2 = 0;  // MTU22カウントストップ
	MTUB.TSTR.BIT.CST1 = 0;  // MTU21カウントストップ
	MTUB.TSTR.BIT.CST2 = 0;  // MTU22カウントストップ

	//STB.CR4.BIT._MTU2 = 0;  // MTU2スタンバイモード解除

	MTU1.TMDR.BIT.MD = 4;  // 位相計数モード 209
	MTU2.TMDR.BIT.MD = 4;

	MTU1.TCNT = 0;  // カウンタクリア
	MTU2.TCNT = 0;

	MTUA.TSTR.BIT.CST1 = 1;  // MTU21カウントスタート
	MTUA.TSTR.BIT.CST2 = 1;  // MTU22カウントスタート
	MTUB.TSTR.BIT.CST1 = 1;  // MTU21カウントスタート
	MTUB.TSTR.BIT.CST2 = 1;  // MTU22カウントスタート
}

// ----------------------------
// --- クロック端子入力設定 ---
// ----------------------------
void
initClock( void )
{
	//P24をMTCLKA-A P25をMTCLKB-A P22をMTCLKC-A P23をMTCLKD-A端子として選択
	IOPORT.PFCMTU.BIT.TCLKS = 0;
}

// -------------------------
// --- I/Oピン初期化関数 ---
// -------------------------
void initIO( void )
{
	//---- スタートスイッチ設定 ---
	PORTA.DDR.BIT.B6 = 0;  // 白スイッチ用ポート　入力に設定	0:入力 1:出力
	PORTA.ICR.BIT.B6 = 1;  // 入力バッファ設定					0:無効 1:有効
	PORTA.DDR.BIT.B5 = 0;  // 白スイッチ用ポート　入力に設定	0:入力 1:出力
	PORTA.ICR.BIT.B5 = 1;  // 入力バッファ設定					0:無効 1:有効
	PORTA.DDR.BIT.B4 = 0;  // 白スイッチ用ポート　入力に設定	0:入力 1:出力
	PORTA.ICR.BIT.B4 = 1;  // 入力バッファ設定					0:無効 1:有効

	PORT3.DDR.BIT.B1 = 1;  // ポンプ制御用ポート　出力に設定	0:入力 1:出力
	PORT3.DR.BIT.B1  = 1;  // ポンプ停止

	// --- フォトリフレクタ設定 ---
	PORT4.DDR.BIT.B6 = 0;  // Photo_4
	PORT4.ICR.BIT.B6 = 1;
	PORT4.DDR.BIT.B7 = 0;  // Photo_1
	PORT4.ICR.BIT.B7 = 1;
	PORT2.DDR.BIT.B6 = 0;  // Photo_RR
	PORT2.ICR.BIT.B6 = 1;
	PORT2.DDR.BIT.B7 = 0;  // Photo_RL
	PORT2.ICR.BIT.B7 = 1;

	// --- Arduino通信用設定 ---
	PORTC.DDR.BIT.B4 = 1;  // 通信(グリッパ用サーボモータ)
	PORTC.DDR.BIT.B5 = 1;
	PORTC.DDR.BIT.B6 = 0;  // 通信(超音波センサ広域用)
	PORTC.ICR.BIT.B6 = 1;
	PORTC.DDR.BIT.B7 = 1;  // 予備 Arduino D4

	PORT5.DDR.BIT.B2 = 0;  // 超音波センサ用ポート　入力設定
	PORT5.ICR.BIT.B2 = 1;  // 入力バッファの設定

	// --- Arduino for HUG通信設定用 ---
	PORTD.DDR.BIT.B0 = 1;
	PORTD.DDR.BIT.B1 = 1;
	PORTD.DDR.BIT.B2 = 1;
	PORTD.DDR.BIT.B3 = 1;
}

// ------------------
// --- RXの初期化 ---
// ------------------
static void
init_micon( void )
{
	initIO();
	initClock();
	InitCMT1();
	ad_setup();
	initMotor();
	initMTU_enco();
}

// ------------------------
// --- ロボットの初期化 ---
// ------------------------
static void
init_robot( void )
{
	init_micon();
	init_para();
	init_flag();
}

// --------------------------
// --- パラメータの初期化 ---
// --------------------------
static void
init_para( void )
{
	int	jnt;
	jnt= Jnt1;

	// --- フラグの初期化 ---
	All_black_flag = 0;
	Feed_flag = 0;
	search_end_flag = 0;

	// --- 初期時間をセット ---
	Ct.dTime.startVal = 0;

	// --- 変数の初期化 ---
	for( jnt=MOTOR_L; jnt<=MOTOR_R; jnt++ ){
		Ct.jnt[jnt].present.d = 0;
	}

	// --- ハードウェアパラメータ ---
	Ki.W= 0.272f;   // ホイール間距離 [m]：大=>旋回量up  0.272
	Ki.r= 0.0305f;  // ホイール半径   [m]
	Ct.WPulse2Rad = 2.0f*PI/2000.0f;  // エンコーダのパルスを回転角[rad]に変換
	Ct.Tr= 21.3f;   // モータ減速比

	// --- ロボットのゲインをセット ---
	for(jnt = MOTOR_L; jnt<=MOTOR_R; jnt++){
		Ct.jnt[jnt].gain.kp = 2000.0f;
		Ct.jnt[jnt].gain.kv =  100.0f;
	}

	// --- motorの設定 ---
	// 回転方向をセット
	Ct.mot_dir[MOTOR_L] =  1;
	Ct.mot_dir[MOTOR_R] = -1;

	// --- encoder の設定 ---
	// 回転方向をセット
	Ct.enco_dir[MOTOR_L] =  1;
	Ct.enco_dir[MOTOR_R] = -1;

	// 変数の初期化
	for( jnt=MOTOR_L; jnt<=MOTOR_R; jnt++ ){
		Ct.enco[jnt].present.d  = 0;
		Ct.tmp_enco_val[jnt]    = 0;
		Ct.start_present_d[jnt] = 0;
	}
}

// ------------------------
// --- 時間スタート関数 ---
// ------------------------
static void
start_time( ct_timeType *p )
{
	p->val = p->startVal;
	p->inc = UntilInc;
}

// ----------------------
// --- 時間をリセット ---
// ----------------------
static void
reset_time( ct_timeType *p )
{
	p->val = p->startVal;
	p->inc = Stopped;
}

// --------------------
// --- 時間更新関数 ---
// --------------------
static int
inc_time( ct_timeType *p )
{
	int ret;

	ret = !Reached;

	if( p->inc != Stopped ){
		if( p->val < p->stopVal ){
			p->val ++;
		}
		else{
			ret = Reached;
		}
	}
	return(ret);
}

// --------------------------
// --- モーター制御関数
// --------------------------
void motor(int duty, int motNum)
{
	if( motNum == MOTOR_R ){
		if(duty > 0){
			MTU9.TGRB = duty;
			PORT5.DR.BIT.B1 = 1;
		}
		else if(duty < 0){
			MTU9.TGRB =-duty;
			PORT5.DR.BIT.B1 = 0;
		}
		else{
			MTU9.TGRB = 0;
			PORT5.DR.BIT.B1 = 1;
		}
	}

	else if( motNum == MOTOR_L ){
		if(duty > 0){
			MTU6.TGRB = duty;
			PORT5.DR.BIT.B0 = 1;
		}
		else if(duty < 0){
			MTU6.TGRB = -duty;
			PORT5.DR.BIT.B0 = 0;
		}
		else{
			MTU6.TGRB = 0;
			PORT5.DR.BIT.B0 = 1;
		}
	}
}

// ------------------------------
// --- エンコーダ値の読込関数 ---
// ------------------------------
static int enco( int no )
{
	Ct.enco[no].last.d = Ct.enco[no].present.d;

	if( no == MOTOR_L ){
		Ct.enco[no].present.d = MTU2.TCNT;
	}
	else if( no == MOTOR_R ){
		Ct.enco[no].present.d = MTU1.TCNT;
	}

	if( Ct.enco[no].present.d > 32767 ){
		Ct.enco[no].present.d -= 65536;
	}

	Ct.enco[no].present.delta = Ct.enco[no].present.d - Ct.enco[no].last.d;

	if( Ct.enco[no].present.delta < -30000 ){
		Ct.enco[no].present.delta += 65536;
	}
	else if( Ct.enco[no].present.delta > 30000 ){
		Ct.enco[no].present.delta -= 65536;
	}

	Ct.tmp_enco_val[no] += Ct.enco[no].present.delta;

	return( Ct.tmp_enco_val[no] );
}

// ------------------------------
// --- プログラム終了時の処理 ---
// ------------------------------
static void
cool_down( void )
{
	STOP_FEED;

	motor(0,MOTOR_L);
	motor(0,MOTOR_R);

	rprintln("Program has done.");
}

// ------------------------
// --- PDライントレース ---
// ------------------------
void Line_Trace_PD( int sensor_2, int sensor_3 )
{

	static int diff_0, diff_1;  // diff0: 前回の差分，diff1: 今回の差分
	float dt = RsampTime;       // 処理周期

	static float P,D;
	static int PD;
	// int L_power, R_power;　// デバッグ用に50行目にstaticで定義．必要に応じて要修正

	diff_0 = diff_1;  // 差分を保存
	diff_1 = sensor_2 - sensor_3;  // Photo_2とPhoto_3の差分を求める．

	P = diff_1 * KP;  // P成分
	D = (diff_1 - diff_0)/dt * KD;  // D成分

	PD = (int)(P+D);  // int型に変換

	// 〇〇〇●
	if( Photo_1 == WHITE && Photo_2 <= 300 && Photo_3 <= 300 && Photo_4 == BLACK ){
		L_power =  base_duty;
		R_power = -base_duty;
	}
	// 〇〇●●
	else if( Photo_1 == WHITE && Photo_2 < 300 && Photo_3 > 300 && Photo_4 == BLACK ){
		L_power =  base_duty;
		R_power = -base_duty*0.5;
	}
	// 〇〇●〇
	else if( Photo_1 == WHITE && Photo_2 < 300 && Photo_3 > 300 && Photo_4 == WHITE ){
		L_power = base_duty - PD;
		R_power = 0;
	}
	// 〇●●〇 センサの配置の都合上、このパターンは存在しない
	else if( Photo_1 == WHITE && Photo_2 > 300 && Photo_3 > 300 && Photo_4 == WHITE ){
		L_power = base_duty - PD;
		R_power = base_duty + PD;
	}
	// 〇●〇〇
	else if( Photo_1 == WHITE && Photo_2 > 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = 0;
		R_power = base_duty + PD;
	}
	// ●●〇〇
	else if( Photo_1 == BLACK && Photo_2 > 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = -base_duty;
		R_power =  base_duty;
	}
	// ●〇〇〇
	else if( Photo_1 == BLACK && Photo_2 < 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = -base_duty;
		R_power =  base_duty;
	}
	// ●●●●
	else if( Photo_1 == BLACK && Photo_2 > 300 && Photo_3 > 300 && Photo_4 == BLACK ){
		L_power = base_duty - PD;
		R_power = base_duty + PD;
	}
	// 〇〇〇〇
	else{
		L_power = base_duty - PD;
		R_power = base_duty + PD;
	}

	motor( L_power*LD , MOTOR_L );
	motor( R_power*RD , MOTOR_R );
}


// -------------------------------
// --- PDライントレース (slow) ---
// -------------------------------
void Line_Trace_PD_slow( int sensor_2, int sensor_3 )
{
	static int diff_0, diff_1;  // diff0: 前回の差分，diff1: 今回の差分
	float dt = RsampTime;       // 処理周期

	static float P,D;
	static int PD;
	// int L_power, R_power;　// デバッグ用に50行目にstaticで定義．必要に応じて要修正

	diff_0 = diff_1;  // 差分を保存
	diff_1 = sensor_2 - sensor_3;  // Photo_2とPhoto_3の差分を求める．

	P = diff_1 * KP;  // P成分
	D = (diff_1 - diff_0)/dt * KD;  // D成分

	PD = (int)(P+D);  // int型に変換

	// 〇〇〇●
	if( Photo_1 == WHITE && Photo_2 <= 300 && Photo_3 <= 300 && Photo_4 == BLACK ){
		L_power =  base_duty2;
		R_power = -base_duty2;
	}
	// 〇〇●●
	else if( Photo_1 == WHITE && Photo_2 < 300 && Photo_3 > 300 && Photo_4 == BLACK ){
		L_power =  base_duty2;
		R_power = -base_duty2*0.5;
	}
	// 〇〇●〇
	else if( Photo_1 == WHITE && Photo_2 < 300 && Photo_3 > 300 && Photo_4 == WHITE ){
		L_power = base_duty2 - PD;
		R_power = 0;
	}
	// 〇●●〇 センサの配置の都合上、このパターンは存在しない
	else if( Photo_1 == WHITE && Photo_2 > 300 && Photo_3 > 300 && Photo_4 == WHITE ){
		L_power = base_duty2 - PD;
		R_power = base_duty2 + PD;
	}
	// 〇●〇〇
	else if( Photo_1 == WHITE && Photo_2 > 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = 0;
		R_power = base_duty2 + PD;
	}
	// ●●〇〇
	else if( Photo_1 == BLACK && Photo_2 > 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = -base_duty;
		R_power =  base_duty;
	}
	// ●〇〇〇
	else if( Photo_1 == BLACK && Photo_2 < 300 && Photo_3 < 300 && Photo_4 == WHITE ){
		L_power = -base_duty2;
		R_power =  base_duty2;
	}
	// ●●●●
	else if( Photo_1 == BLACK && Photo_2 > 300 && Photo_3 > 300 && Photo_4 == BLACK ){
		L_power = base_duty2 - PD;
		R_power = base_duty2 + PD;
	}
	// 〇〇〇〇
	else{
		L_power = base_duty2 - PD;
		R_power = base_duty2 + PD;
	}

	motor( L_power*LD , MOTOR_L );
	motor( R_power*RD , MOTOR_R );
	/*
	static int diff_0, diff_1;  // diff0: 前回の差分，diff1: 今回の差分
	float dt = RsampTime;  // 処理周期

	static float P,D;
	static int PD;
	int L_power, R_power;

	diff_0 = diff_1;  // 差分を保存
	diff_1 = sensor_2 - sensor_3;  // Photo_2とPhoto_3の差分を求める．

	P = diff_1 * KP;//P成分
	D = (diff_1 - diff_0)/dt * KD;  // D成分

	PD = (int)(P+D);  // int型に変換

	// Photo_1=left photo_4=right
	if( Photo_1 == 1 && Photo_4 ==0 ){
		L_power = base_duty2 - PD + 300;  // 基本となる速度に得られた結果を加減算
		R_power = base_duty2 + PD - 200;
	}
	else if( Photo_1 == 0 && Photo_4 ==1 ){
		L_power = base_duty2 - PD - 200;  // 基本となる速度に得られた結果を加減算
		R_power = base_duty2 + PD + 300;
	}
	else{
		L_power = base_duty2 - PD;  // 基本となる速度に得られた結果を加減算
		R_power = base_duty2 + PD;
	}

	motor( L_power*LD , MOTOR_L );
	motor( R_power*RD , MOTOR_R );
	*/
}

// --------------------------
// --- ライントレース一連 ---
// --------------------------
void Line_Trace( int lap )
{
	int lap_flag;

	for( lap_flag=0; lap_flag<lap; lap_flag++ ){

		All_black_flag= 0;
		Feed_flag= PHOTO;

		while( All_black_flag != 1 ){

			if( Photo_RR == 0 && Photo_RL == 0 ){
				All_black_flag= 1;
				rprintln("Find_ABF");
				sleep( 22 );
			}
		}
		All_black_flag = 0;
	}
	Feed_flag = STOP2;
}

// ---------------------------------
// --- ライントレース一連 (Slow) ---
// ---------------------------------
void Line_Trace_Slow( int lap )
{
	int i, lap_flag;
	char str[30];

	for( lap_flag=0; lap_flag<lap; lap_flag++ ){

		All_black_flag= 0;
		Feed_flag = PHOTO_SLOW;

		while( All_black_flag != 1 ){
			if( (Photo_1 == 0 && Photo_2 >= 400 && Photo_3 >= 400 && Photo_4 == 0) ||
                (Photo_1 == 0 && Photo_2 >= 500 && Photo_3 >= 500) ||
    	        (Photo_4 == 0 && Photo_2 >= 500 && Photo_3 >= 500)){
				   All_black_flag= 1;
				   rprintln("Find_ABF");
				   sleep( 30 );
			}
		}
		All_black_flag = 0;
	}
	Feed_flag = STOP2;
}

// -------------------------------
// --- sleep 関数              ---
// --- sleep sleep_time*10[ms] ---
// -------------------------------
void sleep( int sleep_time )
{
	sleep_count = 0;

	while( sleep_count != sleep_time );
}

// --------------
// --- Go2Pet ---
// --------------
void Go2Pet( void )
{	
	while(ULTRA_SONIC){
		Feed_flag = PHOTO_SLOW; // ペットボトルのときだけゆっくりにする
	}

	Feed_flag = STOP2;

	STOP_PSD_ENABLE = false;

	traj_tracking( 3.0f, 0.0f, 3.0f ); // 4.0

	ARM_LOW;
	POMP_ON;

	sleep( 200 ); //300
	ARM_CATCH;

	sleep( 250 ); //300
	ARM_MIDDLE;

	sleep( 250 ); //300
	//ARM_PUT;


	//sleep( 400 );
}

// -----------------------------------------------------------
// --- 入力バッファに書き込めた文字数. (Max BUFFER_SIZE-1) ---
// --- @return 文字数                                      ---
// --- 読んだ内容は　input_buffer に書いてあります.        ---
// -----------------------------------------------------------
int read_Line(void){

	int i;

	for( i=0; i<BUFFER_SIZE-1; i++ ){

		byte c = charget();
	    input_buffer[i] = c;

		if( ENABLE_CONSOLE_FEED_BACK ){
			putUByte( c );
			rsend();
		}

		if( c == '\r' || c == '\n' ) break;
	}

	// i はこの時点で文字数を表している.
	input_buffer[i] = 0;

	return i;
}

// ---------------
// --- charget ---
// ---------------
int16_t charget(void){

	int16_t x;

	while(1){
		x = getUByte();
		//データが受け取れた時の条件分岐
		if( x >= 0 ){
			//putUByte(x);//デバッグ用
			//rsend();//デバッグ用
			break;
		}
		//データが来てないではなく，エラーが発生したときの条件
		else if( x != -1 ){
			break;
		}
	}
	return x;
}

// ---------------------------
// ---   回収作業全般 ----
// --- Slave()の改良版 ---
// --- 2022/4/29 --------------
// ---------------------------
void Collect(void)
{
	int max_search_front = 7; //6
	//int max_search_back = 5;
	int max_search_back = 3;
	float offset_search = 9.0f;

	//右前の探索開始位置に移動
	//traj_tracking(30.0f, 0.0f, 2.0f);
	translate(RIGHT_SEARCH_START_POS - ADJUSTMENT_SEARCH_START_POS); 
	traj_tracking(ADJUSTMENT_SEARCH_START_POS *2 * PI / 4, -90.0f-2.0f, 2.0f);
	//translate(RIGHT_SEARCH_START_POS);
	//rotate(-90.0f);
	//translate(ADJUSTMENT_SEARCH_START_POS);
	

	//////////////////////
	/// 右前の回収処理 ///
	//////////////////////
	for(step = 0; step < max_search_front; step++){
	// Collect関数内の各オブジェクト検出後の動作判断部分に追加
	// 例：
		if (goal_flag == 0 && step != 6 ) {
			obj1 = search_oneball_or_zeitaku();
		} 
		else if (goal_flag == 1 && step != 6 ){ 
			obj2 = search_oneball_or_zeitaku();
		} 
		else if ( goal_flag == 0 && step == 6 ){
			obj1 = search_zeitaku();
		} 
		else if ( goal_flag == 1 && step == 6 ){
			obj2 = search_zeitaku();
		}
		rprint("right12:");
		rprint(int16_t(step));
		if (goal_flag == 0){
			if (obj1.type != RedBall && obj1.type != BlueBall && obj1.type != Zeitaku){
    		//何もないとき or 認識不可
    		//最後以外は、前方に少し進める
 	  		 translate(offset_search);
   			 continue;
			}
			if(step == 6){
				//見つけた位置から回収する
				switch(obj1.type){
				    case Zeitaku:
				        catch_zeitaku(obj1.distance, obj1.angle);
				        break;
					default:
						break; 
				}
			}else{
				//見つけた位置から回収する
				switch(obj1.type){
				    case RedBall:
			    	case BlueBall:
						catch_ball(obj1.distance, obj1.angle);
			        	break;
				    case Zeitaku:
				        catch_zeitaku(obj1.distance, obj1.angle);
				        break;
				}
			}
			// 次のオブジェクトを探す処理
		    // 現在位置を保持して次のオブジェクトを探す
		    rprintln("Searching for next object");
		    // ここに追加の処理（必要に応じて）
		    translate(offset_search); // 次のステップへ進む
			goal_flag = 1;
		    continue;
 
		// 追加：ゴールフラグに基づいて次の動作を決定
		} else if (goal_flag == 1) {
			if (obj2.type != RedBall && obj2.type != BlueBall && obj2.type != Zeitaku && obj2.type != Goal){
    			//何もないとき or 認識不可
    			//最後以外は、前方に少し進める
   		 		translate(offset_search);
   				continue;
			}
			if(step == 6){
				//見つけた位置から回収する
				switch(obj2.type){
			    	case Zeitaku:
			      		catch_zeitaku(obj2.distance, obj2.angle);
			     		break;
					case Goal:
						break;
				}
			}else{
				//見つけた位置から回収する
				switch(obj2.type){
			    	case RedBall:
			    	case BlueBall:
			     		catch_ball(obj2.distance, obj2.angle);
			      		break;
			    	case Zeitaku:
			      		catch_zeitaku(obj2.distance, obj2.angle);
			     		break;
					case Goal:
						break;
				}
			}
		    // ゴールに向かう処理
		    //ライントレース出来るところまで移動
			
		    translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS +2.0f); // -1.0f削除
		    rotate(-90.0f);
		    //ライントレースで一本目のところまで行く
		    return_to_line();
/*			
			switch(obj2.type){
				case RedBall:
				case BlueBall:
				case Goal:
					//ライントレース出来るところまで移動
					translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS); // -1.0fを削除
					rotate(90.0f);
					return_to_line();
					break;
				case Zeitaku:
					//ライントレース出来るところまで移動
					translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS); // -1.0fを削除
					rotate(-90.0f);
					return_to_line();
					break;
		    }*/
		}
		//排出して元に戻る
		switch(obj1.type){
			case RedBall:
				emit_redball(obj2);
				break;
			case BlueBall:
				emit_blueball(obj2);
				break;
			case Zeitaku:
				emit_zeitaku(obj2);
				break;
		}
		//探索していた位置に移動
		if(step>=5){
			traj_tracking( RIGHT_SEARCH_START_POS * 2 * PI / 4, -91.0f, 3.0f);
			translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		}else{
			translate(RIGHT_SEARCH_START_POS - (offset_search * step + ADJUSTMENT_SEARCH_START_POS));
			traj_tracking( (offset_search * step + ADJUSTMENT_SEARCH_START_POS) * 2 * PI / 4, -91.0f, 3.0f);
			//rotate(-90.0f);
			//translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS);
		}
		//このループをもう一度
		goal_flag = 0;
		step -= 1;
	}

	//右前探索開始位置から左前探索開始位置へ移動
	translate(- offset_search * max_search_front - ADJUSTMENT_SEARCH_START_POS + (LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS));
	traj_tracking( -(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS ) * 2 * PI / 4, -90.0f, 3.0f);
	//rotate(90.0f);
	//translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
	rotate(90.0f);
	translate(ADJUSTMENT_SEARCH_START_POS + 2.0f);


	//////////////////////
	/// 左前の回収処理 ///
	//////////////////////
	for(step = 0; step < max_search_front; step++){
	// Collect関数内の各オブジェクト検出後の動作判断部分に追加
		if (goal_flag == 0 && step != 6) {
			obj1 = search_oneball_or_zeitaku();
		} 
		else if (goal_flag == 1 && step != 6) {
			obj2 = search_oneball_or_zeitaku();
		} 
		else if (goal_flag == 0 && step == 6) {
			obj1 = search_zeitaku();
		} 
		else if (goal_flag == 1 && step == 6) {
			obj2 = search_zeitaku();
		}
		
		
		rprint("left12:");
		rprint(int16_t(step));
		if (goal_flag == 0){
			if (obj1.type != RedBall && obj1.type != BlueBall && obj1.type != Zeitaku){
	    	//何もないとき or 認識不可
    		//最後以外は、前方に少し進める
   			 translate(offset_search);
 	  		 continue;
			}
			if(step == 6){
				//見つけた位置から回収する
				switch(obj1.type){
				    case Zeitaku:
				        catch_zeitaku(obj1.distance, obj1.angle);
				        break;
					default:
						break;
				}
			}else{
				//見つけた位置から回収する
				switch(obj1.type){
				    case RedBall:
			    	case BlueBall:
						catch_ball(obj1.distance, obj1.angle);
			        	break;
				    case Zeitaku:
				        catch_zeitaku(obj1.distance, obj1.angle);
				        break;
				}
			}
			// 次のオブジェクトを探す処理
		    // 現在位置を保持して次のオブジェクトを探す
		    rprintln("Searching for next object");
		    // ここに追加の処理（必要に応じて）
		    translate(offset_search); // 次のステップへ進む
			goal_flag = 1;
		    continue;
 
		// 追加：ゴールフラグに基づいて次の動作を決定
		} else if (goal_flag == 1) {
			if (obj2.type != RedBall && obj2.type != BlueBall && obj2.type != Zeitaku&& obj2.type != Goal){
    			//何もないとき or 認識不可
    			//最後以外は、前方に少し進める
   		 		translate(offset_search);
   				continue;
			}
			if(step == 6){
				//見つけた位置から回収する
				switch(obj2.type){
			    	case RedBall:
			    	case BlueBall:
					obj2.type = None;	//変更0529
			      		break;
			    	case Zeitaku:
			      		catch_zeitaku(obj2.distance, obj2.angle);
			     		break;
					case Goal:
						break;
				}
			}else{
				//見つけた位置から回収する
				switch(obj2.type){
			    	case RedBall:
			    	case BlueBall:
			     		catch_ball(obj2.distance, obj2.angle);
			      		break;
			    	case Zeitaku:
			      		catch_zeitaku(obj2.distance, obj2.angle);
			     		break;
					case Goal:
						break;
				}
			}
		    // ゴールに向かう処理
		    //ライントレース出来るところまで移動
		    translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS +2.0f); // -1.0f削除
		    rotate(-90.0f);
			translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		    //ライントレースで一本目のところまで行く
		    return_to_line();
			
		}
		//排出して元に戻る
		switch(obj1.type){
			case RedBall:
				emit_redball(obj2);
				break;
			case BlueBall:
				emit_blueball(obj2);
				break;
			case Zeitaku:
				emit_zeitaku(obj2);
				break;
		}
		//探索していた位置に移動
		translate(LEFT_SEARCH_START_POS - (offset_search * step + ADJUSTMENT_SEARCH_START_POS));
		traj_tracking( (offset_search * step + ADJUSTMENT_SEARCH_START_POS -3.0f) * 2 * PI / 4, -92.0f, 3.0f);
		//rotate(-90.0f);
		//translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS);
		//このループをもう一度
		goal_flag = 0;
		obj2.type = None;
		step -= 1;
	}
	// 2個目探索中にfor文を抜けた場合，排出してからペットボトルに向かう
	if (goal_flag == 1 && step == max_search_front){
		// ゴールに向かう処理
		//ライントレース出来るところまで移動
		translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS +2.0f); // -1.0f削除
	    rotate(-90.0f);
		translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
	    //ライントレースで一本目のところまで行く
	    return_to_line();
		//排出して元に戻る
		switch(obj1.type){
			case RedBall:
				emit_redball(obj2);
				break;
			case BlueBall:
				emit_blueball(obj2);
				break;
			case Zeitaku:
				emit_zeitaku(obj2);
				break;
		}
		Line_Trace( 1 );

	}else{
		//左前探索域の最奥から少し後退しラインがある方へ向く
		translate(-20.0f);
		rotate(-90.0f);
		//ラインに当たるまで直進
		while(1){
			motor( 180*LD , MOTOR_L ); // 150
			motor( 180*RD , MOTOR_R );
			if(Photo_RR == BLACK && Photo_RL == BLACK){
				break;
			}
		}
		translate(5.0f);
		rotate(90.0f);
	}


	//////////////////////////////
	///ペットボトルの回収処理  ///
	//////////////////////////////
	
	//ペットボトル回収動作
	Go2Pet();
	/*
	//ライントレースなしVer
	translate(-13.0f);
	rotate(-90.0f);
	translate(25.5f);
	sleep( 50 );
	*/
	
	//反転してライントレース
	translate(-10.0f);
	rotate(180.0f - 2.0f);
	return_to_line();        //回収エリア手前のラインに到着
	//少し後ろに下がって，台の前に行く
	translate(-10.0f);
	rotate(90.0f);
	translate(25.5f);
	//sleep( 50 );
	
	// ペットボトルを下ろす  *** debug zen ***
	ARM_PUT;
	sleep( 150 ); //200
	POMP_OFF;
	sleep( 150 ); //200
	ARM_MIDDLE;
	sleep( 300 );

	//右奥の探索開始位置に移動
	//RIGHT_SEARCH_START_POSのところに合わせたい
	//traj_tracking( (-25.5f + (74.5f/*青前から中央ラインまでの距離*/ - RIGHT_SEARCH_START_POS)) * 2 * PI / 4, 90.0f, 3.0f);
	//translate( 35.5f - (74.5f/*青前から中央ラインまでの距離*/ - RIGHT_SEARCH_START_POS));
	//rotate(90.0f);
	//3枠目開始地点まで進みたい（ここは人の判断で変更する）
	//translate( 10.0f );
	//translate(ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 - 10.0f - 23.0f/**/);
	
	//traj_tracking( (- 25.5f + (74.5f/*青前から中央ラインまでの距離*/ - RIGHT_SEARCH_START_POS) +2.0f/*調整*/) * 2 * PI / 4, 90.0f, 2.0f);
	//translate(ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 - 10.0f - 23.0f + 25.5f - (74.5f - RIGHT_SEARCH_START_POS));
	
	//左3枠の探索開始位置に移動
	translate( -41.0f);
	rotate(90.0f);
	//translate( 10.0f ); //ライントレースなしVer
	translate( SECTION_HEIGHT * 2 - 10.0f - 20.0f ); //ライントレースありVer
	
	//////////////////////
	/// 左3枠の回収処理 ///
	//////////////////////
	for(int step = 0; step < max_search_back; step++){
		Object obj = search_maxcoffee_or_pyramid(); //マックス缶とピラミッドを探す
		rprint("left3:");
		rprint(int16_t(step));
		if (obj.type == None){
			//何もないとき
			//最後以外は，前方に少し進める
			translate(offset_search);
			continue;
		}
		//今いる位置からつかんで戻る
		switch(obj.type){
			case Pyramid:
				catch_pyramid(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
				rotate(90.0f);
				translate(38.0f);
				break;
			case MaxCoffee:
				catch_maxcoffee(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
				rotate(90.0f);
				translate(38.0f);
				break;
		}
		//ライントレース出来るところまで移動
		//translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
		//rotate(-90.0f);
		//ライントレースで一本目のところまで行く
		return_to_line();
		//排出して元に戻る
		switch(obj.type){
			case Pyramid:
				emit_pyramid();
				break;
			case MaxCoffee:
				emit_maxcoffee();
				break;
		}
		//探索していた位置に移動
		translate(RIGHT_SEARCH_START_POS);
		//traj_tracking( (offset_search * step + SECTION_HEIGHT * 2 -3.0f) * 2 * PI / 4, -92.0f, 5.0f);
		//translate( ADJUSTMENT_SEARCH_START_POS);
		rotate(-90.0f);
		translate(ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2); //-2.0f削除
		//このループを抜ける
		break;
	}
	
	//////////////////////
	/// 右3枠の回収処理 ///
	//////////////////////
	for(int step = 0; step < max_search_back; step++){
		Object obj = search_maxcoffee_or_pyramid(); //マックス缶とピラミッドを探す
		rprint("right3:");
		rprint(int16_t(step));
		if (obj.type == None){
			//何もないとき
			//最後以外は，前方に少し進める
			translate(offset_search);
			continue;
		}
		//今いる位置からつかんで戻る
		switch(obj.type){
			case Pyramid:
				catch_pyramid(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
				rotate(90.0f);
				//translate(38.0f);
				break;
			case MaxCoffee:
				catch_maxcoffee(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
				rotate(90.0f);
				//translate(38.0f);
				break;
		}
		//ライントレース出来るところまで移動
		//translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
		//rotate(-90.0f);
		//ライントレースで一本目のところまで行く
		return_to_line();
		//排出して元に戻る
		switch(obj.type){
			case Pyramid:
				emit_pyramid();
				break;
			case MaxCoffee:
				emit_maxcoffee();
				break;
		}
		//探索していた位置に移動
		translate(RIGHT_SEARCH_START_POS);
		//traj_tracking( (offset_search * step + SECTION_HEIGHT * 2 -3.0f) * 2 * PI / 4, -92.0f, 5.0f);
		//translate( ADJUSTMENT_SEARCH_START_POS);
		rotate(-90.0f);
		translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2); //-2.0f削除
		//このループをもう一度
		step -= 1;
	}
	
	//////////////////////
	/// 右4枠の回収処理 ///
	//////////////////////
	int step = 0;
	goal_flag = 0;
	for(int step = 0; step < max_search_back; step++){
		if (goal_flag == 0){
			obj1 = search_oneball_or_zeitaku();
		}
		rprint("right4:");
		rprint(int16_t(step));
		if (goal_flag == 0){
			if (obj1.type != RedBall && obj1.type != BlueBall && obj1.type != Zeitaku){
	    		//何もないとき or 認識不可
	    		//最後以外は、前方に少し進める
	 	  		 translate(offset_search);
	   			 continue;
			}
			//見つけた位置から回収する
			switch(obj1.type){
			    case RedBall:
		    	case BlueBall:
		        	catch_ball(obj1.distance, obj1.angle);
		        	break;
			    case Zeitaku:
			        catch_zeitaku(obj1.distance, obj1.angle);
			        break;
			}
			goal_flag = 1;
		}
		// 次のオブジェクトを探す処理
	    // 現在位置を保持して次のオブジェクトを探す
	    rprintln("Searching for next object");
	    // ここに追加の処理（必要に応じて）
		//右探索開始位置から左探索開始位置へ移動
		traj_tracking( -offset_search * step * 2 * PI / 4, -90.0f, 3.0f);
		translate(-(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS)+offset_search * step);
	
		//rotate(90.0f);
		//translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		rotate(90.0f);
		break;
	}
	
	// 万が一何も見つけられずにMaxまでサーチした場合
	if (step == max_search_back){
		// 次のオブジェクトを探す処理
	    // 現在位置を保持して次のオブジェクトを探す
	    rprintln("Searching for next object");
	    // ここに追加の処理（必要に応じて）
		//右探索開始位置から左探索開始位置へ移動
		traj_tracking( -offset_search * step * 2 * PI / 4, -90.0f, 3.0f);
		translate(-(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS)+offset_search * step);
	
		//rotate(90.0f);
		//translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		rotate(90.0f);
	}
	
	//////////////////////
	/// 左4枠の回収処理 ///
	//////////////////////
	for(int step = 0; step < max_search_back; step++){
		if (goal_flag == 0) {
			obj1 = search_oneball_or_zeitaku();
		}else if(goal_flag == 1){
			obj2 = search_oneball_or_zeitaku();
		} 
		rprint("left4:");
		rprint(int16_t(step));
		if (goal_flag == 0){
			if (obj1.type != RedBall && obj1.type != BlueBall && obj1.type != Zeitaku){
	    	//何もないとき or 認識不可
    		//最後以外は、前方に少し進める
   			 translate(offset_search);
 	  		 continue;
			}
			//見つけた位置から回収する
			switch(obj1.type){
			    case RedBall:
		    	case BlueBall:
					catch_ball(obj1.distance, obj1.angle);
		        	break;
			    case Zeitaku:
			        catch_zeitaku(obj1.distance, obj1.angle);
			        break;
			}
			// 次のオブジェクトを探す処理
		    // 現在位置を保持して次のオブジェクトを探す
		    rprintln("Searching for next object");
		    // ここに追加の処理（必要に応じて）
		    translate(offset_search); // 次のステップへ進む
			goal_flag = 1;
		    continue;
 
		// 追加：ゴールフラグに基づいて次の動作を決定
		} else if (goal_flag == 1) {
			if (obj2.type != RedBall && obj2.type != BlueBall && obj2.type != Zeitaku&& obj2.type != Goal){
    			//何もないとき or 認識不可
    			//最後以外は、前方に少し進める
   		 		translate(offset_search);
   				continue;
			}
			//見つけた位置から回収する
			switch(obj2.type){
		    	case RedBall:
		    	case BlueBall:
		     		catch_ball(obj2.distance, obj2.angle);
		      		break;
		    	case Zeitaku:
		      		catch_zeitaku(obj2.distance, obj2.angle);
		     		break;
				case Goal:
					break;
			}
		    //ライントレース出来るところまで移動
			//rotate(-180.0f);
		    translate( - offset_search * step - SECTION_HEIGHT * 3 - ADJUSTMENT_SEARCH_START_POS + 4.0f); // -1.0f削除
		    rotate(-90.0f);
			translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		    //ライントレースで一本目のところまで行く
		    return_to_line();
		}
		//排出して元に戻る
		switch(obj1.type){
			case RedBall:
				emit_redball_last(obj2);
				break;
			case BlueBall:
				emit_blueball_last(obj2);
				break;
			case Zeitaku:
				emit_zeitaku_last(obj2);
				break;
		}
	}
/*
	//////////////////////
	/// 右奥の回収処理 ///
	//////////////////////
	for(int step = 0; step < max_search_back+1; step++){
		Object obj;
		if(step < 3) obj = search_maxcoffee_or_pyramid(); //4回目まではマックス缶とピラミッドを探す
		else obj = search_oneball_or_zeitaku();           //4回目以降はボールと贅沢微糖を探す

		if (obj.type == None){
			//何もないとき
			//最後以外は，前方に少し進める
			translate(offset_search);
			continue;
		}
		//今いる位置からつかんで戻る
		switch(obj.type){
			case RedBall:
			case BlueBall:
				catch_ball(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 ); // -1.0fを削除
				rotate(90.0f);
				break;
			case Zeitaku:
				catch_zeitaku(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
				rotate(-90.0f);
				break;
			case Pyramid:
				catch_pyramid(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 + 1.0f); // -1.0fを削除,+ 1.0f追加
				rotate(90.0f);
				break;
			case MaxCoffee:
				catch_maxcoffee(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 + 1.0f); // -1.0fを削除
				rotate(90.0f);
				break;
		}
		//ライントレース出来るところまで移動
		//translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
		//rotate(-90.0f);
		//ライントレースで一本目のところまで行く
		return_to_line();
		//排出して元に戻る
		switch(obj.type){
			case RedBall:
			case Pyramid:
				emit_redball(obj);
				break;
			case BlueBall:
				emit_blueball(obj);
				break;
			case Zeitaku:
				emit_zeitaku(obj);
				break;
			case MaxCoffee:
				emit_maxcoffee();
				break;
		}
		//探索していた位置に移動
		translate(RIGHT_SEARCH_START_POS);
		//traj_tracking( (offset_search * step + SECTION_HEIGHT * 2 -3.0f) * 2 * PI / 4, -92.0f, 5.0f);
		//translate( ADJUSTMENT_SEARCH_START_POS);
		rotate(-90.0f);
		translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
		//このループをもう一度
		step -= 1;
	}
	
	//右奥探索開始位置から左奥探索開始位置へ移動
	translate(-offset_search * max_search_back - ADJUSTMENT_SEARCH_START_POS + (LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS));
	traj_tracking( -(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS) * 2 * PI / 4, -90.0f, 3.0f);
	//rotate(90.0f);
	//translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
	rotate(90.0f);
	translate(ADJUSTMENT_SEARCH_START_POS);

	//////////////////////
	/// 左奥の回収処理 ///
	//////////////////////
	for(int step = 0; step < max_search_back; step++){
		Object obj = search_oneball_or_zeitaku();
		if(step < 4) obj = search_maxcoffee_or_pyramid(); //4回目まではマックス缶とピラミッドを探す
		else obj = search_oneball_or_zeitaku();           //4回目以降はボールと贅沢微糖を探す

		if (obj.type == None){
			//何もないとき
			//最後以外は，前方に少し進める
			translate(offset_search);
			continue;
		}
		//今いる位置からつかんで戻る
		switch(obj.type){
			case RedBall:
			case BlueBall:
				catch_ball(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 ); // -1.0fを削除
				rotate(90.0f);
				break;
			case Zeitaku:
				catch_zeitaku(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
				rotate(-90.0f);
				break;
			case Pyramid:
				catch_pyramid(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 + 1.0f); // -1.0fを削除
				rotate(90.0f);
				break;
			case MaxCoffee:
				catch_maxcoffee(obj.distance, obj.angle);
				//ライントレース出来るところまで移動
				translate( offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 + 1.0f); // -1.0fを削除
				rotate(90.0f);
				break;
		}
		//ライントレース出来るところまで移動
		//translate(- offset_search * step - ADJUSTMENT_SEARCH_START_POS - SECTION_HEIGHT * 2 ); // -1.0fを削除
		//rotate(-90.0f);
		translate(LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS);
		//ライントレースで一本目のところまで行く
		return_to_line();
		//排出して元に戻る
		switch(obj.type){
			case RedBall:
			case Pyramid:
				emit_redball(obj);
				break;
			case BlueBall:
				emit_blueball(obj);
				break;
			case Zeitaku:
				emit_zeitaku(obj);
				break;
			case MaxCoffee:
				emit_maxcoffee();
				break;
		}
		//探索していた位置に移動
		translate(LEFT_SEARCH_START_POS - (offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2));
		traj_tracking((offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2 -3.0f) * 2 * PI / 4, -92.0f, 6.0f);
		//rotate(-90.0f);
		//translate(offset_search * step + ADJUSTMENT_SEARCH_START_POS + SECTION_HEIGHT * 2);
		//このループをもう一度
		step -= 1;
	}

	//青ゴール前の線まで戻る
	translate(-20.0f);
	rotate(-90.0f);
	//ラインに当たるまで直進
	while(1){
		motor( 180*LD , MOTOR_L ); //150
		motor( 180*RD , MOTOR_R );
		if(Photo_RR == BLACK && Photo_RL == BLACK){
			break;
		}
	}
	translate(5.0f);
	rotate(-90.0f);

	void return_to_line();
	Line_Trace(4); //1

	//ここが終わる時点で青ゴールの方を向いて止まっているはず。
	*/
}

// ----------------------------------
// --- 車輪の中心からの距離を計算 ---
// ----------------------------------
float calculate_distance_from_steer_center( float dis, float deg ){

	float a, b;

	a = dis * cos( deg * Deg2Rad );
	b = dis * sin( deg * Deg2Rad );

	float center_distance = sqrt( pow( ( DISTANCE_FROM_STEER_CENTER + a ), 2 ) + pow( b, 2 ) )
									   - DISTANCE_FROM_STEER_CENTER;

	return (center_distance);
}

// ----------------------------------
// --- 車輪の中心からの角度を計算 ---
// ----------------------------------
float calculate_angle_from_steer_center( float dis, float deg ){

	float a, b;

	a = dis * cos( deg * Deg2Rad );
	b = dis * sin( deg * Deg2Rad );

	float center_angle = ( atan2( b,( DISTANCE_FROM_STEER_CENTER + a ) ) ) * Rad2Deg;

	return (center_angle);
}
/*
// ------------------------------------------
// --- ハグを使った場合のラインに戻る処理 ---
// ------------------------------------------
void back_set_posi_HUG( float dis, float deg, float time, char color, int16_t search_space_flag,
                        int r_count, int l_count ){

	if( search_space_flag == RIGHT ){
		rprint("Now:RIGHT");
	}
	else{
		rprint("Now:LEFT");
	}

	// 探索時と同じ車体の向きに合わせる処理
	if (color ==  'r' || color ==  'b'){
		// 赤ボール，青ボール
		traj_tracking( -1.0f*(-1.0f * dis - 8.5f+2.5f), 0.0f, time );  // キャッチのため接近→戻す
	}
	else if(color == 'p'){
		// ピラミッド
		traj_tracking( -1.0f*(-1.0f * dis - 8.5f+3.0f), 0.0f, time );
	}
	else {
		// マックス缶
		traj_tracking( -1.0f*(-1.0f * dis - 8.5f+1.0f), 0.0f, time );
	}

	traj_tracking(  0.0f, -180.0f, 3.0f );  // ハグをボールに向ける→戻す
	traj_tracking(  5.0f,    0.0f, 1.0f );  // 旋回前に車体とボールがぶつからないよう後退→戻す
	traj_tracking(  0.0f,    -deg, time );  // ボールの方向に向く→戻す

	// 見つけた所からラインが見つかるところまで移動
	if( search_space_flag == RIGHT ){
		// 右側を探索した場合
		traj_tracking( r_count * -9.0f, 0.0f, 3.0f );
		traj_tracking( -ADJUSTMENT_SEARCH_START_POS, 0.0f, 1.0f );
		traj_tracking( 0.0f, -90.0f, 2.0f );
	}
	else{
    	// 左側を探索した場合
		traj_tracking( l_count * -9.0f, 0.0f, 3.0f );
		traj_tracking( -ADJUSTMENT_SEARCH_START_POS, 0.0f, 1.0f );
		traj_tracking( 0.0f, -90.0f, 2.0f );
		traj_tracking( LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS, 0.0f, 3.0f );
	}

	// ライン復帰用
	if( Photo_2 <= 700 && Photo_3 <= 700 ){
		while( Photo_2 < 700 && Photo_3 < 700 ){
			motor( -200*LD, MOTOR_L );
			motor(  200*RD, MOTOR_R );
		}
	}

	Line_Trace( 1 );
}

// --------------------------------------------------------
// --- UVGを使った場合のラインに戻る処理（贅沢微糖のみ）---
// --------------------------------------------------------
void back_set_posi_UVG( float dis, float deg, float time, char color,
					    int16_t search_space_flag, int r_count, int l_count ){

	traj_tracking( -dis, 0.0f, time );
	traj_tracking( 0.0f, -deg, time );

	// 見つけた所からラインが見つかるところまで移動
	if(search_space_flag == RIGHT){
    	// 右側を探索した場合
		traj_tracking( r_count * -9.0f, 0.0f, 3.0f);
		traj_tracking( -ADJUSTMENT_SEARCH_START_POS, 0.0f, 1.0f);
		traj_tracking( 0.0f, -90.0f, 2.0f);
	}
	else{
		// 左側を探索した場合
		traj_tracking( l_count * -9.0f, 0.0f, 3.0f);
		traj_tracking( -ADJUSTMENT_SEARCH_START_POS, 0.0f, 1.0f);
		traj_tracking( 0.0f, -90.0f, 2.0f);
		traj_tracking( LEFT_SEARCH_START_POS - RIGHT_SEARCH_START_POS, 0.0f, 3.0f);
	}

	// ライン復帰用
	if(Photo_2 <= 700 && Photo_3 <= 700 ){
		while(Photo_2 < 700 && Photo_3 < 700){
			motor( -200*LD, MOTOR_L );
			motor(  200*RD, MOTOR_R );
		}
	}

	Line_Trace( 1 );
}
*/
////////////////////////////////
///  今の位置でラインを探す  ///
////////////////////////////////
void return_to_line(void){
	if( Photo_2 <= 700 && Photo_3 <= 700 ){
		while( Photo_2 < 700 && Photo_3 < 700 ){
			motor( 50*LD, MOTOR_L );// -200
			motor( 200*RD, MOTOR_R );
		}
	}
	//ラインを見つけてから最初の線まで移動する
	Line_Trace( 1 );
}

// ------------------
// --- PSD_sensor ---
// ------------------
void PSD_sensor(void)
{
	Xf[0] = Xf[1];
	Xf[2] = Xf[3];
	Xf[4] = Xf[5];
	Yf[0] = Yf[1];
	Yf[2] = Yf[3];
	Yf[4] = Yf[5];

	// フィルタリング処理　少し遅延がある．
	Xf[1] = (float)(AD1.ADDRA);
	Xf[3] = (float)(AD1.ADDRB);
	Xf[5] = (float)(AD0.ADDRA);

	// ローパスフィルタ
	Yf[1] = (float)(Yf[0]*F_B_2+ (Xf[0] + Xf[1])*F_C_2);  // フィルタリング後の値
	Yf[3] = (float)(Yf[2]*F_B_2+ (Xf[2] + Xf[3])*F_C_2);
	Yf[5] = (float)(Yf[4]*F_B_2+ (Xf[4] + Xf[5])*F_C_2);

	// 距離に変換
	Distance1 = -278.79*Yf[1]*3.3f/1024.0f + 653.34f;  // GP2Y0E03（距離センサ）
	Distance2 = -278.79*Yf[3]*3.3f/1024.0f + 653.34f;
	Distance3 = -278.79*Yf[5]*3.3f/1024.0f + 653.34f;
}

// **************
// *** main() ***
// **************
void main(void)
{
	//volatile int  lap_flag;	これらはいらない
	//int16_t  LP,RP;
	//int16_t  MR,ML;

	// システムクロックの設定
	SYSTEM.SCKCR.BIT.ICK = 0x00;
	SYSTEM.SCKCR.BIT.PCK = 0x01;
	SYSTEM.SCKCR.BIT.BCK = 0x01;

	// シリアル通信の初期化設定
	initConsole( 115200 );

	init_robot();

	rflush();

	// 初期位置
	sleep( 100 );

	ARM_LOW;

	sleep( 100 );

	POMP_OFF;

	sleep( 100 );

	// PSD_secer
    Fs_2 = 1.0f/RsampTime;	// サンプリング周波数[Hz]の計算
    Fac_2= ( (float)tanf( PI*Fc_2/Fs_2 ) )/( PI/Fs_2 );  // プリワーピング

    F_B_2= ( 2.0f - Fac_2/Fs_2 )/( 2.0f + Fac_2/Fs_2 );
    F_C_2= ( Fac_2/Fs_2 )/( 2.0f + Fac_2/Fs_2 );

	Xf[1] = (float)(AD1.ADDRA);
	Xf[3] = (float)(AD1.ADDRB);
	Xf[5] = (float)(AD0.ADDRA);

	rprintln("Start!");

	rprintln("Press Start-switch!");

	HUG_START_POSI;  // 調整が終わったら外す．
	sleep( 200 );

	// *** debug zen ***
	// POMP_ON;  // UVG調整用
	//
	// 旋回角度の調整用
	// traj_tracking( 0.0f,  90.0f, 3.0f );
	// traj_tracking( 0.0f, -90.0f, 3.0f );
	// *****************

	while( true ){

		int16_t white = WHITE_SWITCH;
		int16_t blue = BLUE_SWITCH;
		int16_t black = BLACK_SWITCH;

		// ------------------
		// --- 白スイッチ ---
		// ------------------
		if( white == 0 ){

			rprintln("Pressed White-switch");
			
			//Raspiへのシリアル通信
			//スクリューを回転させる
			rflush();
			rprintln("m");

			// 最初の挙動
			transform_robot();

			// 自由ボール用の処理
			free_ball2();

			// 探索開始位置へ
			go2search_start_posi();

			// 回収・運搬作業
			Collect();

			// 終了
			cool_down();
		}

		// ------------------
		// --- 青スイッチ ---
		// ------------------
		// 自由ボール＋ペットボトル： 約2分
		if( blue == 0 ){

			rprintln("Pressed Blue-switch");
			
			ARM_MIDDLE;
			sleep( 1000 );
			while(1){
			}

			// 初期状態は大きさの問題からロボットをたたんでる．
			// その状態から動作モードに変形
			// UVGが上がり，ホールド機構が上がる．
			transform_robot();

			// 自由ボールを落とす処理
			// チップスターから空気を排気
			free_ball2();

			// ペットボトルに行き，ペットボトルを取る処理
			Go2Pet();

			// ペットボトルを置く処理
			PUT_PET();

			// ペットボトルを置いた位置からゴールに戻る処理
			// 引数'x'がその処理の指令値
			return_bonus( 'x' );
		}

		// ------------------
		// --- 黒スイッチ ---
		// ------------------
		if( black == 0 ){
			rprintln("Pressed Black-switch");
			
			
			//ピラミッドチェック用
			while (1){
				HUG_PYRAMID_UP;
				sleep( 1000 );
				HUG_PYRAMID_DOWN;
				sleep( 500 );

//				translate(-8);
//				sleep(500);

				HUG_CATCH;
				translate(-8.0f);
				sleep( 500 );
				
				HUG_WAIT_UP;
				sleep( 500 );
				
				translate(8.0f);
				sleep(500);
			}
			
			// 紐の長さチェック用
			while (1){
				HUG_START_POSI;
				sleep( 800 );
			
				HUG_BULLDOZE;
				sleep( 800 );
			
				HUG_CATCH;
				sleep( 800 );
			}
			
			
			ARM_MIDDLE;

			sleep( 300 );
			while (1){
				
				search_oneball_or_zeitaku();
				sleep( 500 );
				
			}
			
			//rotate(360.0f);
			//sleep( 1000 );
			//rotate(-90.0f);
			/*
			sleep( 1500 );
			translate(20);
			sleep( 1000 );
			translate(-20);
			*/

		}
	}
}

// --------------------------------------------
// --- 最初の挙動アームと後ろの機構を上げる ---
// --------------------------------------------
void transform_robot( void ){
	
	translate( 55.0f ); //55cm前進
	
	OPEN_UP;

	//sleep( 200 );

	ARM_MIDDLE;

	sleep( 200 );
}

// ------------------------------
// --- 各種フラグ関係の初期化 ---
// ------------------------------
void init_flag( void )
{
	// 各種フラグの初期化
	STOP_PSD_ENABLE = false;

	CHANGE_SPACE_FLAG = 0;

	search_space_flag = RIGHT;

	FINISH_FLAG = false;

	right_one_flag   = false;
	right_two_flag   = false;
	right_three_flag = false;
	right_four_flag  = false;

	left_one_flag   = false;
	left_two_flag   = false;
	left_three_flag = false;
	left_four_flag  = false;

	GO_AHEAD_FLAG = false;
	
	goal_flag = 0;
}
/*
// ****************************************************************************
// *** 進行距離を見て，現在の状況を判断し，RXからRaspberry Piへの指令を決定 ***
// ****************************************************************************
void RXPi( void )
{
	rprintln("RXPi");

	rflush();

	if( moving_robot_distance >= 0 and moving_robot_distance <= FIRST_END_POS ){

		rprintln("a");

		if( search_space_flag == RIGHT ){

			rprintln("1枠の右");

			right_one_flag   = true;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = false;
		}

		if( search_space_flag == LEFT ){

			rprintln("1枠の左");

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = true;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = false;
		}
	}

	if( moving_robot_distance > FIRST_END_POS and moving_robot_distance <= SECOND_END_POS ){

		rprintln("a");

		if( search_space_flag == RIGHT ){

			rprintln("2枠の右");

			right_one_flag   = false;
			right_two_flag   = true;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = false;
		}

		if( search_space_flag == LEFT ){

			rprintln("2枠の左");

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = true;
			left_three_flag  = false;
			left_four_flag   = false;
		}
	}

	if( moving_robot_distance > SECOND_END_POS and moving_robot_distance <= THIRD_END_POS ){

		rprintln("d");

		if( search_space_flag == RIGHT ){

			rprintln("3枠の右");

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = true;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = false;
		}

		if( search_space_flag == LEFT ){

			rprintln("3枠の左");

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = true;
			left_four_flag   = false;
		}
	}

	if( moving_robot_distance > THIRD_END_POS ){

		rprintln("a");

		if( search_space_flag == RIGHT ){

			rprintln("4枠の右");

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = true;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = false;
		}

		if( search_space_flag == LEFT ){

			rprintln("4枠の左");

			FINISH_FLAG = true;

			right_one_flag   = false;
			right_two_flag   = false;
			right_three_flag = false;
			right_four_flag  = false;

			left_one_flag    = false;
			left_two_flag    = false;
			left_three_flag  = false;
			left_four_flag   = true;
		}
	}
}
*/

// ------------------------------------------------------
// --- ボール(青赤)と缶を探索する -------------------------
// --- return: Object構造体　取るべき対象物を1つだけ返す ---
// ------------------------------------------------------
Object search_oneball_or_zeitaku(void){
	//Raspiへのシリアル通信
	//ボールと贅沢微糖の画像認識を実行する
	rflush();
	rprintln("a");
	int size = read_Line();  //結果を読み込み

	//得られた文字列を分割
	char *mode, *frst, *scnd, *thrd, *type, *goal;

	mode = strtok(input_buffer,",");
	frst = strtok(NULL,","); //距離
	scnd = strtok(NULL,","); //角度
	thrd = strtok(NULL,","); //時間（3）
	type = strtok(NULL,","); //r, b. z. m, p, g：２種類同じものを検出し，１つだけをもってゴールへ
	goal = strtok(NULL,","); //goal_flag = 1ならゴールへ向かう
	
	
	if(mode[0] == 'n'){
		//物体を見つけられなかった場合
		Object obj = {None, 0.0f, 0.0f};
		return obj;
	}

	//結果をdouble型に変換
	double x1, x2, x3, cal_dis, cal_deg;
	x1 = atof(frst);  // [mm]
	x2 = atof(scnd);  // [deg]
	x3 = atof(thrd);  // [s] 使っていない
	
	int goal_flag = atoi(goal);
		
	//車体からの相対位置の算出
	float cal_distance = calculate_distance_from_steer_center(x1, x2);
	float cal_angle = calculate_angle_from_steer_center(x1, x2);

	if( goal_flag == 0 ){
		if (type[0] == 'r') obj1.type = RedBall;
		else if (type[0] == 'b') obj1.type = BlueBall;
		else if (type[0] == 'z') obj1.type = Zeitaku;
		else if (type[0] == 'g') obj1.type = Goal;
		else obj1.type = None;
		obj1.distance = cal_distance;
		obj1.angle = cal_angle;	
	
		return obj1;
	
	}else {
		if (type[0] == 'r') obj2.type = RedBall;
		else if (type[0] == 'b') obj2.type = BlueBall;
		else if (type[0] == 'z') obj2.type = Zeitaku;
		else if (type[0] == 'g') obj2.type = Goal;
		else obj2.type = None;
		obj2.distance = cal_distance;
		obj2.angle = cal_angle;
		
		return obj2;
	}
		

}

Object search_zeitaku(void){
		//Raspiへのシリアル通信
	//ボールと贅沢微糖の画像認識を実行する
	rflush();
	rprintln("c");
	int size = read_Line();  //結果を読み込み

	//得られた文字列を分割
	char *mode, *frst, *scnd, *thrd, *type, *goal;

	mode = strtok(input_buffer,",");
	frst = strtok(NULL,","); //距離
	scnd = strtok(NULL,","); //角度
	thrd = strtok(NULL,","); //時間（3）
	type = strtok(NULL,","); //r, b. z. m, p, g：２種類同じものを検出し，１つだけをもってゴールへ
	goal = strtok(NULL,","); //goal_flag = 1ならゴールへ向かう
	
	
	if(mode[0] == 'n'){
		//物体を見つけられなかった場合
		Object obj = {None, 0.0f, 0.0f};
		return obj;
	}

	//結果をdouble型に変換
	double x1, x2, x3, cal_dis, cal_deg;
	x1 = atof(frst);  // [mm]
	x2 = atof(scnd);  // [deg]
	x3 = atof(thrd);  // [s] 使っていない
	
	int goal_flag = atoi(goal);
		
	//車体からの相対位置の算出
	float cal_distance = calculate_distance_from_steer_center(x1, x2);
	float cal_angle = calculate_angle_from_steer_center(x1, x2);

	if( goal_flag == 0 ){
		if (type[0] == 'r') obj1.type = RedBall;
		else if (type[0] == 'b') obj1.type = BlueBall;
		else if (type[0] == 'z') obj1.type = Zeitaku;
		else if (type[0] == 'g') obj1.type = Goal;
		else obj1.type = None;
		obj1.distance = cal_distance;
		obj1.angle = cal_angle;	
	
		return obj1;
	
	}else {
		if (type[0] == 'r') obj2.type = RedBall;
		else if (type[0] == 'b') obj2.type = BlueBall;
		else if (type[0] == 'z') obj2.type = Zeitaku;
		else if (type[0] == 'g') obj2.type = Goal;
		else obj2.type = None;
		obj2.distance = cal_distance;
		obj2.angle = cal_angle;
		
		return obj2;
	}
}
	

// ------------------------------------------------------
// --- マックス缶(横おき)とボールピラミッドを探索する -------
// --- return: Object構造体　取るべき対象物を1つだけ返す ---
// ------------------------------------------------------
Object search_maxcoffee_or_pyramid(void){
	//Raspiへのシリアル通信
	//マックスコーヒーとボールピラミッドの画像認識を実行する
	rprintln("function: search_maxcoffee_or_pyramid");
	rflush();
	rprintln("d");
	int size = read_Line();  //結果を読み込み

	//得られた文字列を分割
	char *mode, *frst, *scnd, *thrd, *type;
	mode = strtok(input_buffer,",");
	frst = strtok(NULL,",");
	scnd = strtok(NULL,",");
	thrd = strtok(NULL,",");
	type  = strtok(NULL,",");

	if(mode[0] == 'n'){
		//物体を見つけられなかった場合
		Object obj = {None, 0.0f, 0.0f};
		return obj;
	}

	//結果をdouble型に変換
	double x1, x2, x3, cal_dis, cal_deg;
	x1 = atof(frst);  // [mm]
	x2 = atof(scnd);  // [deg]
	x3 = atof(thrd);  // [s] 使っていない

	//車体からの相対位置の算出
	float cal_distance = calculate_distance_from_steer_center(x1, x2);
	float cal_angle = calculate_angle_from_steer_center(x1, x2);

	Object obj;
	if (type[0] == 'p') obj.type = Pyramid;
	else if (type[0] == 'm') obj.type = MaxCoffee;
	else obj.type = None;
	obj.distance = cal_distance;
	obj.angle = cal_angle;

	return obj;
	rprint("function end: search_maxcoffee_or_pyramid");
}

// -----------------------------------------------
// --- ライントレースし，探索開始位置に向かう．---
// -----------------------------------------------
void go2search_start_posi( void ){

	Line_Trace( 3 );

	//traj_tracking( -35.0f, 0.0f, 3.0f );

	//Line_Trace( 1 );

	//traj_tracking( RIGHT_SEARCH_START_POS, 0.0f, 3.0f );

	//traj_tracking( 0.0f, -90.0f, 3.0f );

	//traj_tracking( ADJUSTMENT_SEARCH_START_POS, 0.0f, 1.0f );
}

// -----------------------------
// --- スタート & 自由ボール ---
// -----------------------------
void free_ball2( void ){

	STOP_PSD_ENABLE = false;

	POMP_ON;

	sleep( 100 );

	POMP_OFF;
}

// --------------------------------
// --- ペットボトルを置きに行く ---
// --------------------------------
void PUT_PET( void ){

	while( Photo_1==1 || Photo_4==1 ){
		motor( -350 * RD, MOTOR_R );
		motor( -350 * LD, MOTOR_L );
	}

	traj_tracking( -11.0f, 0.0f, 2.0f );

	traj_tracking( 0.0f, -80.0f, 3.0f );

	// ライン復帰用
	if( Photo_2 <= 700 && Photo_3 <= 700 ){
		while( Photo_2 < 700 && Photo_3 < 700 ){
			motor(  200*LD , MOTOR_L );
			motor( -200*RD , MOTOR_R );
		}
	}

	// ペットボトル排出用
	Line_Trace( 2 );

	traj_tracking( 0.0f, 90.0f, 3.0f );
	traj_tracking( 7.0f,  0.0f, 2.0f );


	sleep( 50 );

	// ペットボトルを下ろす  *** debug zen ***
	POMP_OFF;
	sleep( 200 );
	ARM_MIDDLE;
	sleep( 300 );

	//traj_tracking( -10.0f, 0.0f, 1.0f );
}

// ---------------------------------------------------
// --- リターンボーナス用                          ---
// --- 基本的には，RaspberryPiからの指令を基に制御 ---
// ---------------------------------------------------
void return_bonus( char color ){

	float adjs_dis;

	adjs_dis = 2.0f;

	// *** 中央台（ペットボトル） ***
	if (color == 'x'){

		traj_tracking( 0.0f, -90.0f, 2.0f );

		// 復帰用プログラム
		Line_Trace( 1 );

		HUG_START_POSI;

		ARM_LOW;

		traj_tracking( 22.0f + adjs_dis, -10.0f, 2.0f );
		traj_tracking( 22.0f + adjs_dis,  10.0f, 2.0f );
	}

	// *** 赤ゴール（赤ボール or ボールピラミッド）***
	if ( color == 'r' || color == 'p' ){

		traj_tracking( 0.0f, -100.0f, 2.0f );

		HUG_START_POSI;

		sleep( 100 );

		ARM_LOW;

		sleep( 100 );

		traj_tracking( 22.0f + adjs_dis, -10.0f, 2.0f );
		traj_tracking( 22.0f + adjs_dis,  10.0f, 2.0f );
	}

	// *** 黄ゴール（贅沢微糖 or マックス缶）***
	if ( color == 'z' || color == 'm' ){

		traj_tracking( 0.0f, 90.0f, 2.0f );

		// 復帰用プログラム
		Line_Trace( 1 );

		HUG_START_POSI;

		sleep( 100 );

		ARM_LOW;

		sleep( 100 );

		traj_tracking( 22.0f + adjs_dis, -10.0f, 2.0f );
		traj_tracking( 22.0f + adjs_dis,  10.0f, 2.0f );
	}

	// *** 青ゴール（青ボール）***
	if ( color == 'b' ){

		traj_tracking( -25.0f,   0.0f, 3.0f ); //dis = -42.0f
		traj_tracking(   0.0f, -90.0f, 2.0f );

		// 復帰用プログラム
		Line_Trace( 2 );

		HUG_START_POSI;

		sleep( 100 );

		ARM_LOW;

		sleep( 100 );

		traj_tracking( 22.0f + adjs_dis, -10.0f, 2.0f );
		traj_tracking( 22.0f + adjs_dis,  10.0f, 2.0f );
	}
}

// ----------------------------------------------------------------------------
// --- ペットボトル Get後，青ゴール手前のラインから，右探索開始位置まで移動 ---
// ----------------------------------------------------------------------------
void GO_CATCH_PUT_PET( void ){

	Go2Pet();

	PUT_PET();
	/*

	traj_tracking(  0.0f, 90.0f, 3.0f );

	Line_Trace( 1 );

	traj_tracking( -35.0f, 0.0f, 3.0f );

	Line_Trace( 1 );
	*/
	// 右探索のセットポジションへ
	//traj_tracking( 49.0f, 0.0f, 3.0f );
}

// -------------------------------------------------------------------
// --- セットポジションから各ゴールへ運搬・排出した後，戻ってくる．---
// --- blue:1  yellow:2  red:3  pet:4                              ---
// -------------------------------------------------------------------
void Emit_Items2( char color, int count )
{
	STOP_PSD_ENABLE = false;

	// *** 青ゴール ***
	if( color == 'b' ){

		traj_tracking(   0.0f, 180.0f, 5.0f );
		traj_tracking( -48.0f,   0.0f, 4.0f );

		// 青ボールを落とす
		OPEN_UP;

		sleep( 200 );

		traj_tracking( 42.0f, 0.0f, 3.0f );

		if(FINISH_FLAG){

			rprintln("リターンボーナス");

			return_bonus( color );

			while( true );
		}

		Line_Trace( 1 );

		traj_tracking( -35.0f, 0.0f, 3.0f );

		Line_Trace( 1 );

		// セットポジションへ
		go2setposi();

		rprint("セットポジションへ（1:右，2:左）");
		rprintln( search_space_flag );

		traj_tracking( 0.0f, -90.0f, 3.0f );
	}

	// *** 黄 or 赤ゴールへ ***
	else if(color == 'z' || color == 'm' || color == 'r' || color == 'p' ){

		if( color == 'z' || color == 'm' ){
			Line_Trace( 1 );
		}
		else if( color == 'r' || color == 'p' ){
			Line_Trace( 2 );
		}

		if( color == 'z' ){
			traj_tracking(  0.0f, -90.0f, 3.0f );
			traj_tracking( 10.0f,   0.0f, 1.0f );

			POMP_OFF;

			sleep( 300 );

			traj_tracking( -10.0f, 0.0f, 1.0f );

			if( FINISH_FLAG ){
				rprintln("リターンボーナス");
				return_bonus( color );

				while( true );
			}
			else{
				traj_tracking(  0.0f, -90.0f, 3.0f );
				traj_tracking( 10.0f,   0.0f, 1.0f );
			}
		}
		else if( color == 'r' || color == 'p' || color == 'm' ){

			traj_tracking(   0.0f, 90.0f, 3.0f );
			traj_tracking( -20.0f,  0.0f, 2.0f );

			OPEN_UP;

			sleep( 200 );

			traj_tracking( 20.0f, 0.0f, 3.0f );

			if( FINISH_FLAG ){
				rprintln("リターンボーナス");
				return_bonus( color );

				while( true );
			}
			else{
				traj_tracking(  0.0f, 90.0f, 3.0f );
				traj_tracking( 10.0f,  0.0f, 1.0f );
			}
		}

		// *** セットポジションへ ***
		if( color == 'm' || color == 'z' ){
			Line_Trace( 1 );
		}
		else if( color == 'r' || color == 'p' ){
			Line_Trace( 2 );
		}

		traj_tracking( -35.0f, 0.0f, 3.0f );

		Line_Trace( 1 );

		go2setposi();

		rprint("セットポジションへ（1:右, 2:左）");
		rprintln( search_space_flag );

		traj_tracking( 0.0f, -90.0f, 3.0f );
	}
}

void emit_redball(Object obj2){
	Line_Trace( 2 );
	//お尻を付ける
	rotate(90.0f);
	translate(-20.0f);
	//赤ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	//戻る
	translate(20.0f);
	rotate(90.0f);
	
	if(obj2.type == Zeitaku){
			translate(10.0f);
			Line_Trace( 1 );
				
			//お尻を付ける
			rotate(90.0f);
			translate(10.0f);
			//贅沢微糖を落とす
			POMP_OFF;
			sleep( 300 );
			//戻る
			translate(-10.0f);
			rotate(-90.0f);
			translate(10.0f);
			Line_Trace( 1 );
	}else {
		translate(10.0f);
		Line_Trace( 2 );
	}
}

void emit_redball_last(Object obj2){
	Line_Trace( 2 );
	//お尻を付ける
	rotate(90.0f);
	translate(-20.0f);
	//赤ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	//戻る
	translate(20.0f);
	rotate(90.0f);
	
	if(obj2.type == Zeitaku){
		translate(10.0f);
		Line_Trace( 1 );
			
		//お尻を付ける
		rotate(90.0f);
		translate(10.0f);
		//贅沢微糖を落とす
		POMP_OFF;
		sleep( 300 );
		//戻る
		translate(-10.0f);
		rotate(90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}else {
		rotate(180.0f);
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}
}

void emit_blueball(Object obj2){
	//お尻を付ける
	rotate(180.0f);
	translate(-48.0f);
	//青ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	
	if(obj2.type == Zeitaku){
		translate(20.0f);
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		
		rotate(-90.0f);
		translate(10.0f);
		//贅沢微糖を落とす
		POMP_OFF;
		sleep( 300 );
		//戻る
		translate(-10.0f);
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
	}else {
	translate(40.0f);//42
	//戻る
	Line_Trace( 1 );
	}
}

void emit_blueball_last(Object obj2){
	//お尻を付ける
	rotate(180.0f);
	translate(-48.0f);
	//青ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	
	if(obj2.type == Zeitaku){
		translate(20.0f);
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		
		rotate(-90.0f);
		translate(10.0f);
		//贅沢微糖を落とす
		POMP_OFF;
		sleep( 300 );
		//戻る
		translate(-10.0f);
		rotate(90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}else {
		translate(19.0f);//20
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 2 );
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}
}

void emit_zeitaku(Object obj2){
	Line_Trace( 1 );
	//頭を向ける
	rotate(-90.0f);
	translate(10.0f);
	//贅沢微糖を落とす
	POMP_OFF;
	sleep( 300 );
	//戻る
	translate(-10.0f);
	
	if(obj2.type == RedBall){
		rotate(90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		rotate(90.0f);
		translate(-20.0f);
		OPEN_UP;
		sleep( 150 ); //200
		//戻る
		translate(20.0f);
		rotate(90.0f);			
		translate(10.0f);
		Line_Trace( 2 );		
	}else if(obj2.type == BlueBall){
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		translate(-48.0f);
		OPEN_UP;
		sleep( 150 ); //200
		//戻る
		translate(40.0f);//42
		Line_Trace( 1 );	
	}else{
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
	}
}

void emit_zeitaku_last(Object obj2){
	Line_Trace( 1 );
	//頭を向ける
	rotate(-90.0f);
	translate(10.0f);
	//贅沢微糖を落とす
	POMP_OFF;
	sleep( 300 );
	//戻る
	translate(-10.0f);
	
	if(obj2.type == RedBall){
		rotate(90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		rotate(90.0f);
		translate(-20.0f);
		OPEN_UP;
		sleep( 150 ); //200
		
		translate(20.0f);
		rotate(-90.0f);			
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}else if(obj2.type == BlueBall){
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		translate(-48.0f);
		OPEN_UP;
		sleep( 150 ); //200
		
		translate(19.0f);
		rotate(-90.0f);
		translate(10.0f);
		Line_Trace( 2 );
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );	
	}else{
		rotate(90.0f);
		translate(10.0f);
		Line_Trace( 1 );
		//リターンボーナス
		HUG_START_POSI;
		ARM_LOW;
		//ARM_PUT;
		sleep( 200 );
		traj_tracking( 50.0f, -5.0f, 3.0f );
	}
}

void emit_maxcoffee(void){
	Line_Trace( 1 );
	//お尻を付ける
	rotate(90.0f);
	translate(-20.0f);
	//赤ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	//戻る
	translate(20.0f);
	rotate(90.0f);
	translate(10.0f);
	Line_Trace( 1 );
}

void emit_pyramid(void){
	Line_Trace( 2 );
	//お尻を付ける
	rotate(90.0f);
	translate(-20.0f);
	//赤ボールを落とす
	OPEN_UP;
	sleep( 150 ); //200
	//戻る
	translate(20.0f);
	rotate(90.0f);
	translate(10.0f);
	Line_Trace( 2 );
}

// ------------------------------------------------------------------
// --- ボールをゴールに運んだ後，指定されたセットポジションに移動 ---
// ------------------------------------------------------------------
void go2setposi( void ){

	// 右探索だった際の処理
	if( search_space_flag == RIGHT ){

		// 右の1番目処理をして戻ってきたとき
		if( right_one_flag == true ){

			traj_tracking( RIGHT_SEARCH_START_POS, 0.0f, 3.0f );
		}

		// 右の2番目の処理をして，右2番目の探索範囲を終了してないとき
		if( right_two_flag == true  && moving_robot_distance < SECOND_END_POS ){

			traj_tracking( RIGHT_SEARCH_START_POS, 0.0f, 3.0f );
		}

		// 右の2番目の処理をして，右の2番目の探索範囲が終了したとき
		if( right_two_flag == true && moving_robot_distance > SECOND_END_POS ){

			search_space_flag = LEFT;

			right_search_moving_distance = moving_robot_distance;
			moving_robot_distance = 0.0f;

			traj_tracking( LEFT_SEARCH_START_POS, 0.0f, 3.0f );
		}

		// 右探索3番目の処理
		if( right_three_flag == true && find_flag == true ){

			right_search_moving_distance = moving_robot_distance;
			moving_robot_distance = left_search_moving_distance;

			traj_tracking( LEFT_SEARCH_START_POS, 0.0f, 3.0f );

			search_space_flag = LEFT;
		}

		// 右探索4番目の処理
		if( right_four_flag == true && find_flag == true ){

			//right_search_moving_distance = moving_robot_distance;
			moving_robot_distance = left_search_moving_distance;

			traj_tracking( LEFT_SEARCH_START_POS, 0.0f, 3.0f );

			search_space_flag = LEFT;
		}
	}

	// 左探索だったときの処理
	if( search_space_flag == LEFT ){

		// 左探索1番目の処理
		if( left_one_flag == true ){

			traj_tracking( LEFT_SEARCH_START_POS, 0.0f, 3.0f );
		}

		// 左探索2番目で探索範囲をまだ探索してないときの処理
		if( left_two_flag == true  && moving_robot_distance < SECOND_END_POS ){

			traj_tracking( LEFT_SEARCH_START_POS, 0.0f, 3.0f );
		}

		// 左探索2番目で探索範囲が終了したときの処理
		if( left_two_flag == true && moving_robot_distance > SECOND_END_POS ){

			search_space_flag = RIGHT;

			left_search_moving_distance = moving_robot_distance;
			moving_robot_distance = right_search_moving_distance;

			GO_CATCH_PUT_PET();
		}

		// 左探索3番目
		if( left_three_flag == true && find_flag == true ){

			left_search_moving_distance = moving_robot_distance;
			moving_robot_distance = right_search_moving_distance;

			traj_tracking( RIGHT_SEARCH_START_POS, 0.0f, 3.0f );

			search_space_flag = RIGHT;
		}

		// 左探索4番目
		if( left_four_flag == true && find_flag == true ){

			rprintln("return bouns");

			while(true);
		}
	}
}

// --------------------
// --- object_catch ---
// --------------------
void object_catch( char shape ){

	if( shape == 'm' || shape == 'p' || shape == 'r' || shape == 'b'){

		HUG_WAIT_DOWN;
		sleep( 300 );

		HUG_CATCH;
		sleep( 400 );

		HUG_WAIT_UP;
		sleep( 300 );
	}

	if( shape == 'z' ){

		ARM_LOW;
		sleep( 300 );

		ARM_CATCH;

		POMP_ON;

		sleep( 300 );

		ARM_MIDDLE;
		sleep( 300 );
	}
}

void catch_ball(float distance, float angle){
	if(step >= 4){
		//後退して向きを変える
		rotate(angle);
		translate(-5.0f);
		rotate(180.0f);
	
		//ブルドーザー
		HUG_BULLDOZE;
		sleep( 100 );
		traj_tracking( -distance - 3.0f, 0.0f, 4.0f ); // 6.5f -4.0f

		//HUG
		//HUG_WAIT_DOWN;
		//sleep( 300 );
		HUG_CATCH;
		sleep( 300 );
		HUG_WAIT_UP;
		traj_tracking( distance +2.0f, 0.0f, 3.0f );
		//sleep( 200 );

		//戻る
		//translate(2.0f); //6.5f
		rotate(-180.0f-angle);
		//translate(5.0f);
		//rotate(-angle);
	}else{
		//後退して向きを変える
		//rotate(angle);
		translate(-5.0f);
		rotate(180.0f);
	
		//ブルドーザー
		HUG_BULLDOZE;
		sleep( 100 );
		traj_tracking( -distance - 7.0f, 0.0f, 5.0f ); // 6.5f

		//HUG
		//HUG_WAIT_DOWN;
		//sleep( 300 );
		HUG_CATCH;
		sleep( 300 );
		HUG_WAIT_UP;
		traj_tracking( distance + 2.0f, 0.0f, 3.0f );
		//sleep( 200 );

		//戻る
		//translate(2.0f); //6.5f
		rotate(-180.0f);
		//translate(5.0f);
		//rotate(-angle);
	}
}

void catch_zeitaku(float distance, float angle){
	//接近
	rotate(angle);
	if(distance<=8.0f){
		translate(distance -1.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +1.0f);
	}else if(distance<=10.0f){
		translate(distance -2.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +2.0f);
	}else if(distance<=12.0f){
		translate(distance -3.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +3.0f);
	}else if(distance<=14.0f){
		translate(distance -4.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +4.0f);
	}else if(distance<=16.0f){
		translate(distance -5.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +5.0f);
	}else if(distance<=18.0f){
		translate(distance -6.0f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +6.0f);
	}else if(distance<=20.0f){
		translate(distance -7.5f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +7.5f);
	}else if(distance<=25.0f){
		translate(distance -8.5f); // -5.0f追加,-7.0
		//磁石でキャッチ
		translate(-distance +8.5f);
	}else if(distance<=30.0f){
		translate(distance -9.0f); // -5.0f追加
		//磁石でキャッチ
		translate(-distance +9.0f);
	}else{
		translate(distance -10.0f); // -5.0f追加
		//磁石でキャッチ
		translate(-distance +10.0f);
	}

	//UVG
	ARM_LOW;
	sleep( 200 ); //300
	ARM_CATCH;
	POMP_ON;
	sleep( 200 ); //300
	ARM_MIDDLE;
	sleep( 200 );

	//戻る
	//translate(-distance +5.0f); // +5.0f追加
	rotate(-angle);
}

void catch_pyramid(float distance, float angle){
	/*
	translate(-5.0f);
	rotate(180.0f);
	sleep( 100 );
	traj_tracking( 17.0f-distance, 0.0f, 2.0f ); //17
	sleep( 100 );
	//ブルドーザー
	//HUG_BULLDOZE;
	//traj_tracking( -32.5f, 0.0f, 2.0f ); //5.0f
	//traj_tracking( -16.25f, 0.0f, 1.0f );

	//HUG
	//HUG_WAIT_DOWN;
	//sleep( 300 );
	HUG_CATCH;
	traj_tracking( -32.5f, 0.0f, 2.0f );
	//translate(7.5f);
	sleep( 300 ); //400
	HUG_WAIT_UP;
	sleep( 200 );
	
	translate(32.5f-(22.0f-distance));
	*/
	
	//接近
	rotate(angle);
	translate(-5.0f);
	rotate(180.0f);
	//translate(-distance ); // 5.0 // -1.0f

	//HUG
/*	HUG_PYRAMID_UP;
	sleep( 300 );
	HUG_PYRAMID_DOWN;
	sleep( 300 );
	HUG_CATCH;
	sleep( 400 );
	HUG_WAIT_UP;
	sleep( 300 );*/
	
	HUG_PYRAMID_UP;
	sleep( 200 );
	
	translate(-distance +3.0f);//1.5
	
	HUG_PYRAMID_DOWN;
	sleep( 300 );

	HUG_CATCH;
	translate(-9.0f);//8.0
	sleep( 300 );
	
/*	rotate(30.0f);
	sleep(200);
	rotate(-.600f);
	sleep(200);
	rotate(30.0f);
	sleep(200);*/
	
								
	HUG_WAIT_UP;
	sleep( 200 );
				
	//translate(8.0f);
	//sleep(300);
	
	

	//戻る
	translate(distance+1.0f); // 5.0 // 2.0
	rotate( -angle);
	//translate(5.0f);
	//rotate(-angle);
	
	

}

void catch_maxcoffee(float distance, float angle){
	//接近
	rotate(angle);
	translate(-5.0f);
	rotate(-180.0f);
	translate(-distance - 2.0f); // 6.5f -2.0

	//HUG_PYRAMID_UP;
	//sleep( 100 );
	HUG_PYRAMID_DOWN;
	sleep( 150 ); //300
	
	HUG_CATCH;
	translate(-5.0f);
	sleep( 150 ); //200
	
	//戻る
	translate(distance + 2.0f); //6.5f
	
	HUG_WAIT_UP;
	//sleep( 300 );

	rotate( -angle);
	//translate(5.0f);
	//rotate(-angle);

}

#ifdef __cplusplus
void abort( void )
{}
#endif
